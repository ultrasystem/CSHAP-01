***************
*** 59,71 ****
  #define CREATE_TRACE_POINTS
  #include <trace/events/printk.h>
  
- /*
-  * Architectures can override it:
-  */
- void asmlinkage __attribute__((weak)) early_printk(const char *fmt, ...)
- {
- }
- 
  /* printk's without a loglevel use this.. */
  #define DEFAULT_MESSAGE_LOGLEVEL CONFIG_DEFAULT_MESSAGE_LOGLEVEL
  
--- 59,64 ----
  #define CREATE_TRACE_POINTS
  #include <trace/events/printk.h>
  
  /* printk's without a loglevel use this.. */
  #define DEFAULT_MESSAGE_LOGLEVEL CONFIG_DEFAULT_MESSAGE_LOGLEVEL
  
***************
*** 1252,1257 ****
  	return do_syslog(type, buf, len, SYSLOG_FROM_READER);
  }
  
  static bool __read_mostly ignore_loglevel;
  
  static int __init ignore_loglevel_setup(char *str)
--- 1245,1306 ----
  	return do_syslog(type, buf, len, SYSLOG_FROM_READER);
  }
  
+ #ifdef CONFIG_EARLY_PRINTK
+ struct console *early_console;
+ 
+ void early_vprintk(const char *fmt, va_list ap)
+ {
+ 	if (early_console) {
+ 		char buf[512];
+ 		int n = vscnprintf(buf, sizeof(buf), fmt, ap);
+ 
+ 		early_console->write(early_console, buf, n);
+ 	}
+ }
+ 
+ asmlinkage void early_printk(const char *fmt, ...)
+ {
+ 	va_list ap;
+ 
+ 	va_start(ap, fmt);
+ 	early_vprintk(fmt, ap);
+ 	va_end(ap);
+ }
+ 
+ /*
+  * This is independent of any log levels - a global
+  * kill switch that turns off all of printk.
+  *
+  * Used by the NMI watchdog if early-printk is enabled.
+  */
+ static bool __read_mostly printk_killswitch;
+ 
+ static int __init force_early_printk_setup(char *str)
+ {
+ 	printk_killswitch = true;
+ 	return 0;
+ }
+ early_param("force_early_printk", force_early_printk_setup);
+ 
+ void printk_kill(void)
+ {
+ 	printk_killswitch = true;
+ }
+ 
+ static int forced_early_printk(const char *fmt, va_list ap)
+ {
+ 	if (!printk_killswitch)
+ 		return 0;
+ 	early_vprintk(fmt, ap);
+ 	return 1;
+ }
+ #else
+ static inline int forced_early_printk(const char *fmt, va_list ap)
+ {
+ 	return 0;
+ }
+ #endif
+ 
  static bool __read_mostly ignore_loglevel;
  
  static int __init ignore_loglevel_setup(char *str)
***************
*** 1283,1288 ****
  	if (!console_drivers)
  		return;
  
  	for_each_console(con) {
  		if (exclusive_console && con != exclusive_console)
  			continue;
--- 1332,1338 ----
  	if (!console_drivers)
  		return;
  
+ 	migrate_disable();
  	for_each_console(con) {
  		if (exclusive_console && con != exclusive_console)
  			continue;
***************
*** 1295,1300 ****
  			continue;
  		con->write(con, text, len);
  	}
  }
  
  /*
--- 1345,1351 ----
  			continue;
  		con->write(con, text, len);
  	}
+ 	migrate_enable();
  }
  
  /*
***************
*** 1354,1365 ****
   * interrupts disabled. It should return with 'lockbuf_lock'
   * released but interrupts still disabled.
   */
- static int console_trylock_for_printk(unsigned int cpu)
  	__releases(&logbuf_lock)
  {
  	int retval = 0, wake = 0;
  
- 	if (console_trylock()) {
  		retval = 1;
  
  		/*
--- 1405,1422 ----
   * interrupts disabled. It should return with 'lockbuf_lock'
   * released but interrupts still disabled.
   */
+ static int console_trylock_for_printk(unsigned int cpu, unsigned long flags)
  	__releases(&logbuf_lock)
  {
  	int retval = 0, wake = 0;
+ #ifdef CONFIG_PREEMPT_RT_FULL
+ 	int lock = !early_boot_irqs_disabled && !irqs_disabled_flags(flags) &&
+ 		(preempt_count() <= 1);
+ #else
+ 	int lock = 1;
+ #endif
  
+ 	if (lock && console_trylock()) {
  		retval = 1;
  
  		/*
***************
*** 1512,1517 ****
  	int this_cpu;
  	int printed_len = 0;
  
  	boot_delay_msec();
  	printk_delay();
  
--- 1569,1581 ----
  	int this_cpu;
  	int printed_len = 0;
  
+ 	/*
+ 	 * Fall back to early_printk if a debugging subsystem has
+ 	 * killed printk output
+ 	 */
+ 	if (unlikely(forced_early_printk(fmt, args)))
+ 		return 1;
+ 
  	boot_delay_msec();
  	printk_delay();
  
***************
*** 1631,1638 ****
  	 * The console_trylock_for_printk() function will release 'logbuf_lock'
  	 * regardless of whether it actually gets the console semaphore or not.
  	 */
- 	if (console_trylock_for_printk(this_cpu))
  		console_unlock();
  
  	lockdep_on();
  out_restore_irqs:
--- 1695,1709 ----
  	 * The console_trylock_for_printk() function will release 'logbuf_lock'
  	 * regardless of whether it actually gets the console semaphore or not.
  	 */
+ 	if (console_trylock_for_printk(this_cpu, flags)) {
+ #ifndef CONFIG_PREEMPT_RT_FULL
  		console_unlock();
+ #else
+ 		raw_local_irq_restore(flags);
+ 		console_unlock();
+ 		raw_local_irq_save(flags);
+ #endif
+ 	}
  
  	lockdep_on();
  out_restore_irqs:
***************
*** 1991,1998 ****
  
  int printk_needs_cpu(int cpu)
  {
- 	if (cpu_is_offline(cpu))
- 		printk_tick();
  	return __this_cpu_read(printk_pending);
  }
  
--- 2062,2069 ----
  
  int printk_needs_cpu(int cpu)
  {
+ 	if (unlikely(cpu_is_offline(cpu)))
+ 		__this_cpu_write(printk_pending, 0);
  	return __this_cpu_read(printk_pending);
  }
  
***************
*** 2021,2031 ****
  		goto out;
  
  	len = cont_print_text(text, size);
  	raw_spin_unlock(&logbuf_lock);
  	stop_critical_timings();
  	call_console_drivers(cont.level, text, len);
  	start_critical_timings();
  	local_irq_restore(flags);
  	return;
  out:
  	raw_spin_unlock_irqrestore(&logbuf_lock, flags);
--- 2092,2107 ----
  		goto out;
  
  	len = cont_print_text(text, size);
+ #ifndef CONFIG_PREEMPT_RT_FULL
  	raw_spin_unlock(&logbuf_lock);
  	stop_critical_timings();
  	call_console_drivers(cont.level, text, len);
  	start_critical_timings();
  	local_irq_restore(flags);
+ #else
+ 	raw_spin_unlock_irqrestore(&logbuf_lock, flags);
+ 	call_console_drivers(cont.level, text, len);
+ #endif
  	return;
  out:
  	raw_spin_unlock_irqrestore(&logbuf_lock, flags);
***************
*** 2108,2119 ****
  		console_idx = log_next(console_idx);
  		console_seq++;
  		console_prev = msg->flags;
- 		raw_spin_unlock(&logbuf_lock);
  
  		stop_critical_timings();	/* don't trace print latency */
  		call_console_drivers(level, text, len);
  		start_critical_timings();
  		local_irq_restore(flags);
  	}
  	console_locked = 0;
  
--- 2184,2200 ----
  		console_idx = log_next(console_idx);
  		console_seq++;
  		console_prev = msg->flags;
  
+ #ifndef CONFIG_PREEMPT_RT_FULL
+ 		raw_spin_unlock(&logbuf_lock);
  		stop_critical_timings();	/* don't trace print latency */
  		call_console_drivers(level, text, len);
  		start_critical_timings();
  		local_irq_restore(flags);
+ #else
+ 		raw_spin_unlock_irqrestore(&logbuf_lock, flags);
+ 		call_console_drivers(level, text, len);
+ #endif
  	}
  	console_locked = 0;
  
