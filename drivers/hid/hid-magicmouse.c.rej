***************
*** 370,394 ****
  		input_report_rel(input, REL_Y, y);
  	} else { /* USB_DEVICE_ID_APPLE_MAGICTRACKPAD */
  		input_report_key(input, BTN_MOUSE, clicks & 1);
- 		input_report_key(input, BTN_TOUCH, msc->ntouches > 0);
- 		input_report_key(input, BTN_TOOL_FINGER, msc->ntouches == 1);
- 		input_report_key(input, BTN_TOOL_DOUBLETAP, msc->ntouches == 2);
- 		input_report_key(input, BTN_TOOL_TRIPLETAP, msc->ntouches == 3);
- 		input_report_key(input, BTN_TOOL_QUADTAP, msc->ntouches == 4);
- 		if (msc->single_touch_id >= 0) {
- 			input_report_abs(input, ABS_X,
- 				msc->touches[msc->single_touch_id].x);
- 			input_report_abs(input, ABS_Y,
- 				msc->touches[msc->single_touch_id].y);
- 		}
  	}
  
  	input_sync(input);
  	return 1;
  }
  
- static void magicmouse_setup_input(struct input_dev *input, struct hid_device *hdev)
  {
  	__set_bit(EV_KEY, input->evbit);
  
  	if (input->id.product == USB_DEVICE_ID_APPLE_MAGICMOUSE) {
--- 344,360 ----
  		input_report_rel(input, REL_Y, y);
  	} else { /* USB_DEVICE_ID_APPLE_MAGICTRACKPAD */
  		input_report_key(input, BTN_MOUSE, clicks & 1);
+ 		input_mt_report_pointer_emulation(input, true);
  	}
  
  	input_sync(input);
  	return 1;
  }
  
+ static int magicmouse_setup_input(struct input_dev *input, struct hid_device *hdev)
  {
+ 	int error;
+ 
  	__set_bit(EV_KEY, input->evbit);
  
  	if (input->id.product == USB_DEVICE_ID_APPLE_MAGICMOUSE) {
***************
*** 417,478 ****
  		__set_bit(BTN_TOOL_DOUBLETAP, input->keybit);
  		__set_bit(BTN_TOOL_TRIPLETAP, input->keybit);
  		__set_bit(BTN_TOOL_QUADTAP, input->keybit);
  		__set_bit(BTN_TOUCH, input->keybit);
  		__set_bit(INPUT_PROP_POINTER, input->propbit);
  		__set_bit(INPUT_PROP_BUTTONPAD, input->propbit);
  	}
  
- 	if (report_touches) {
- 		__set_bit(EV_ABS, input->evbit);
- 
- 		input_set_abs_params(input, ABS_MT_TRACKING_ID, 0, 15, 0, 0);
- 		input_set_abs_params(input, ABS_MT_TOUCH_MAJOR, 0, 255 << 2,
- 				     4, 0);
- 		input_set_abs_params(input, ABS_MT_TOUCH_MINOR, 0, 255 << 2,
- 				     4, 0);
- 		input_set_abs_params(input, ABS_MT_ORIENTATION, -31, 32, 1, 0);
- 
- 		/* Note: Touch Y position from the device is inverted relative
- 		 * to how pointer motion is reported (and relative to how USB
- 		 * HID recommends the coordinates work).  This driver keeps
- 		 * the origin at the same position, and just uses the additive
- 		 * inverse of the reported Y.
- 		 */
- 		if (input->id.product == USB_DEVICE_ID_APPLE_MAGICMOUSE) {
- 			input_set_abs_params(input, ABS_MT_POSITION_X,
- 				MOUSE_MIN_X, MOUSE_MAX_X, 4, 0);
- 			input_set_abs_params(input, ABS_MT_POSITION_Y,
- 				MOUSE_MIN_Y, MOUSE_MAX_Y, 4, 0);
- 
- 			input_abs_set_res(input, ABS_MT_POSITION_X,
- 				MOUSE_RES_X);
- 			input_abs_set_res(input, ABS_MT_POSITION_Y,
- 				MOUSE_RES_Y);
- 		} else { /* USB_DEVICE_ID_APPLE_MAGICTRACKPAD */
- 			input_set_abs_params(input, ABS_X, TRACKPAD_MIN_X,
- 				TRACKPAD_MAX_X, 4, 0);
- 			input_set_abs_params(input, ABS_Y, TRACKPAD_MIN_Y,
- 				TRACKPAD_MAX_Y, 4, 0);
- 			input_set_abs_params(input, ABS_MT_POSITION_X,
- 				TRACKPAD_MIN_X, TRACKPAD_MAX_X, 4, 0);
- 			input_set_abs_params(input, ABS_MT_POSITION_Y,
- 				TRACKPAD_MIN_Y, TRACKPAD_MAX_Y, 4, 0);
- 
- 			input_abs_set_res(input, ABS_X, TRACKPAD_RES_X);
- 			input_abs_set_res(input, ABS_Y, TRACKPAD_RES_Y);
- 			input_abs_set_res(input, ABS_MT_POSITION_X,
- 				TRACKPAD_RES_X);
- 			input_abs_set_res(input, ABS_MT_POSITION_Y,
- 				TRACKPAD_RES_Y);
- 		}
  
- 		input_set_events_per_packet(input, 60);
  	}
  
  	if (report_undeciphered) {
  		__set_bit(EV_MSC, input->evbit);
  		__set_bit(MSC_RAW, input->mscbit);
  	}
  }
  
  static int magicmouse_input_mapping(struct hid_device *hdev,
--- 383,448 ----
  		__set_bit(BTN_TOOL_DOUBLETAP, input->keybit);
  		__set_bit(BTN_TOOL_TRIPLETAP, input->keybit);
  		__set_bit(BTN_TOOL_QUADTAP, input->keybit);
+ 		__set_bit(BTN_TOOL_QUINTTAP, input->keybit);
  		__set_bit(BTN_TOUCH, input->keybit);
  		__set_bit(INPUT_PROP_POINTER, input->propbit);
  		__set_bit(INPUT_PROP_BUTTONPAD, input->propbit);
  	}
  
  
+ 	__set_bit(EV_ABS, input->evbit);
+ 
+ 	error = input_mt_init_slots(input, 16);
+ 	if (error)
+ 		return error;
+ 	input_set_abs_params(input, ABS_MT_TOUCH_MAJOR, 0, 255 << 2,
+ 			     4, 0);
+ 	input_set_abs_params(input, ABS_MT_TOUCH_MINOR, 0, 255 << 2,
+ 			     4, 0);
+ 	input_set_abs_params(input, ABS_MT_ORIENTATION, -31, 32, 1, 0);
+ 
+ 	/* Note: Touch Y position from the device is inverted relative
+ 	 * to how pointer motion is reported (and relative to how USB
+ 	 * HID recommends the coordinates work).  This driver keeps
+ 	 * the origin at the same position, and just uses the additive
+ 	 * inverse of the reported Y.
+ 	 */
+ 	if (input->id.product == USB_DEVICE_ID_APPLE_MAGICMOUSE) {
+ 		input_set_abs_params(input, ABS_MT_POSITION_X,
+ 				     MOUSE_MIN_X, MOUSE_MAX_X, 4, 0);
+ 		input_set_abs_params(input, ABS_MT_POSITION_Y,
+ 				     MOUSE_MIN_Y, MOUSE_MAX_Y, 4, 0);
+ 
+ 		input_abs_set_res(input, ABS_MT_POSITION_X,
+ 				  MOUSE_RES_X);
+ 		input_abs_set_res(input, ABS_MT_POSITION_Y,
+ 				  MOUSE_RES_Y);
+ 	} else { /* USB_DEVICE_ID_APPLE_MAGICTRACKPAD */
+ 		input_set_abs_params(input, ABS_X, TRACKPAD_MIN_X,
+ 				     TRACKPAD_MAX_X, 4, 0);
+ 		input_set_abs_params(input, ABS_Y, TRACKPAD_MIN_Y,
+ 				     TRACKPAD_MAX_Y, 4, 0);
+ 		input_set_abs_params(input, ABS_MT_POSITION_X,
+ 				     TRACKPAD_MIN_X, TRACKPAD_MAX_X, 4, 0);
+ 		input_set_abs_params(input, ABS_MT_POSITION_Y,
+ 				     TRACKPAD_MIN_Y, TRACKPAD_MAX_Y, 4, 0);
+ 
+ 		input_abs_set_res(input, ABS_X, TRACKPAD_RES_X);
+ 		input_abs_set_res(input, ABS_Y, TRACKPAD_RES_Y);
+ 		input_abs_set_res(input, ABS_MT_POSITION_X,
+ 				  TRACKPAD_RES_X);
+ 		input_abs_set_res(input, ABS_MT_POSITION_Y,
+ 				  TRACKPAD_RES_Y);
  	}
  
+ 	input_set_events_per_packet(input, 60);
+ 
  	if (report_undeciphered) {
  		__set_bit(EV_MSC, input->evbit);
  		__set_bit(MSC_RAW, input->mscbit);
  	}
+ 
+ 	return 0;
  }
  
  static int magicmouse_input_mapping(struct hid_device *hdev,
***************
*** 532,539 ****
  	/* We do this after hid-input is done parsing reports so that
  	 * hid-input uses the most natural button and axis IDs.
  	 */
- 	if (msc->input)
- 		magicmouse_setup_input(msc->input, hdev);
  
  	if (id->product == USB_DEVICE_ID_APPLE_MAGICMOUSE)
  		report = hid_register_report(hdev, HID_INPUT_REPORT,
--- 500,512 ----
  	/* We do this after hid-input is done parsing reports so that
  	 * hid-input uses the most natural button and axis IDs.
  	 */
+ 	if (msc->input) {
+ 		ret = magicmouse_setup_input(msc->input, hdev);
+ 		if (ret) {
+ 			hid_err(hdev, "magicmouse setup input failed (%d)\n", ret);
+ 			goto err_stop_hw;
+ 		}
+ 	}
  
  	if (id->product == USB_DEVICE_ID_APPLE_MAGICMOUSE)
  		report = hid_register_report(hdev, HID_INPUT_REPORT,
