***************
*** 104,110 ****
  	struct s3c_hsotg_req	*req;
  	struct dentry		*debugfs;
  
- 	spinlock_t		lock;
  
  	unsigned long		total_data;
  	unsigned int		size_loaded;
--- 104,109 ----
  	struct s3c_hsotg_req	*req;
  	struct dentry		*debugfs;
  
  
  	unsigned long		total_data;
  	unsigned int		size_loaded;
***************
*** 128,134 ****
   * @driver: USB gadget driver
   * @plat: The platform specific configuration data.
   * @regs: The memory area mapped for accessing registers.
-  * @regs_res: The resource that was allocated when claiming register space.
   * @irq: The IRQ number we are using
   * @supplies: Definition of USB power supplies
   * @dedicated_fifos: Set if the hardware has dedicated IN-EP fifos.
--- 127,132 ----
   * @driver: USB gadget driver
   * @plat: The platform specific configuration data.
   * @regs: The memory area mapped for accessing registers.
   * @irq: The IRQ number we are using
   * @supplies: Definition of USB power supplies
   * @dedicated_fifos: Set if the hardware has dedicated IN-EP fifos.
***************
*** 149,156 ****
  	struct usb_gadget_driver *driver;
  	struct s3c_hsotg_plat	 *plat;
  
  	void __iomem		*regs;
- 	struct resource		*regs_res;
  	int			irq;
  	struct clk		*clk;
  
--- 147,155 ----
  	struct usb_gadget_driver *driver;
  	struct s3c_hsotg_plat	 *plat;
  
+ 	spinlock_t              lock;
+ 
  	void __iomem		*regs;
  	int			irq;
  	struct clk		*clk;
  
***************
*** 888,894 ****
  	struct s3c_hsotg_req *hs_req = our_req(req);
  	struct s3c_hsotg_ep *hs_ep = our_ep(ep);
  	struct s3c_hsotg *hs = hs_ep->parent;
- 	unsigned long irqflags;
  	bool first;
  
  	dev_dbg(hs->dev, "%s: req %p: %d@%p, noi=%d, zero=%d, snok=%d\n",
--- 887,892 ----
  	struct s3c_hsotg_req *hs_req = our_req(req);
  	struct s3c_hsotg_ep *hs_ep = our_ep(ep);
  	struct s3c_hsotg *hs = hs_ep->parent;
  	bool first;
  
  	dev_dbg(hs->dev, "%s: req %p: %d@%p, noi=%d, zero=%d, snok=%d\n",
***************
*** 907,925 ****
  			return ret;
  	}
  
- 	spin_lock_irqsave(&hs_ep->lock, irqflags);
- 
  	first = list_empty(&hs_ep->queue);
  	list_add_tail(&hs_req->queue, &hs_ep->queue);
  
  	if (first)
  		s3c_hsotg_start_req(hs, hs_ep, hs_req, false);
  
- 	spin_unlock_irqrestore(&hs_ep->lock, irqflags);
- 
  	return 0;
  }
  
  static void s3c_hsotg_ep_free_request(struct usb_ep *ep,
  				      struct usb_request *req)
  {
--- 905,934 ----
  			return ret;
  	}
  
  	first = list_empty(&hs_ep->queue);
  	list_add_tail(&hs_req->queue, &hs_ep->queue);
  
  	if (first)
  		s3c_hsotg_start_req(hs, hs_ep, hs_req, false);
  
  	return 0;
  }
  
+ static int s3c_hsotg_ep_queue_lock(struct usb_ep *ep, struct usb_request *req,
+ 			      gfp_t gfp_flags)
+ {
+ 	struct s3c_hsotg_ep *hs_ep = our_ep(ep);
+ 	struct s3c_hsotg *hs = hs_ep->parent;
+ 	unsigned long flags = 0;
+ 	int ret = 0;
+ 
+ 	spin_lock_irqsave(&hs->lock, flags);
+ 	ret = s3c_hsotg_ep_queue(ep, req, gfp_flags);
+ 	spin_unlock_irqrestore(&hs->lock, flags);
+ 
+ 	return ret;
+ }
+ 
  static void s3c_hsotg_ep_free_request(struct usb_ep *ep,
  				      struct usb_request *req)
  {
***************
*** 1375,1383 ****
  	 */
  
  	if (hs_req->req.complete) {
- 		spin_unlock(&hs_ep->lock);
  		hs_req->req.complete(&hs_ep->ep, &hs_req->req);
- 		spin_lock(&hs_ep->lock);
  	}
  
  	/*
--- 1384,1392 ----
  	 */
  
  	if (hs_req->req.complete) {
+ 		spin_unlock(&hsotg->lock);
  		hs_req->req.complete(&hs_ep->ep, &hs_req->req);
+ 		spin_lock(&hsotg->lock);
  	}
  
  	/*
***************
*** 1396,1423 ****
  }
  
  /**
-  * s3c_hsotg_complete_request_lock - complete a request given to us (locked)
-  * @hsotg: The device state.
-  * @hs_ep: The endpoint the request was on.
-  * @hs_req: The request to complete.
-  * @result: The result code (0 => Ok, otherwise errno)
-  *
-  * See s3c_hsotg_complete_request(), but called with the endpoint's
-  * lock held.
-  */
- static void s3c_hsotg_complete_request_lock(struct s3c_hsotg *hsotg,
- 					    struct s3c_hsotg_ep *hs_ep,
- 					    struct s3c_hsotg_req *hs_req,
- 					    int result)
- {
- 	unsigned long flags;
- 
- 	spin_lock_irqsave(&hs_ep->lock, flags);
- 	s3c_hsotg_complete_request(hsotg, hs_ep, hs_req, result);
- 	spin_unlock_irqrestore(&hs_ep->lock, flags);
- }
- 
- /**
   * s3c_hsotg_rx_data - receive data from the FIFO for an endpoint
   * @hsotg: The device state.
   * @ep_idx: The endpoint index for the data
--- 1405,1410 ----
  }
  
  /**
   * s3c_hsotg_rx_data - receive data from the FIFO for an endpoint
   * @hsotg: The device state.
   * @ep_idx: The endpoint index for the data
***************
*** 1436,1441 ****
  	int max_req;
  	int read_ptr;
  
  	if (!hs_req) {
  		u32 epctl = readl(hsotg->regs + DOEPCTL(ep_idx));
  		int ptr;
--- 1423,1429 ----
  	int max_req;
  	int read_ptr;
  
+ 
  	if (!hs_req) {
  		u32 epctl = readl(hsotg->regs + DOEPCTL(ep_idx));
  		int ptr;
***************
*** 1451,1458 ****
  		return;
  	}
  
- 	spin_lock(&hs_ep->lock);
- 
  	to_read = size;
  	read_ptr = hs_req->req.actual;
  	max_req = hs_req->req.length - read_ptr;
--- 1439,1444 ----
  		return;
  	}
  
  	to_read = size;
  	read_ptr = hs_req->req.actual;
  	max_req = hs_req->req.length - read_ptr;
***************
*** 1479,1486 ****
  	 * alignment of the data.
  	 */
  	readsl(fifo, hs_req->req.buf + read_ptr, to_read);
- 
- 	spin_unlock(&hs_ep->lock);
  }
  
  /**
--- 1465,1470 ----
  	 * alignment of the data.
  	 */
  	readsl(fifo, hs_req->req.buf + read_ptr, to_read);
  }
  
  /**
***************
*** 1601,1607 ****
  			s3c_hsotg_send_zlp(hsotg, hs_req);
  	}
  
- 	s3c_hsotg_complete_request_lock(hsotg, hs_ep, hs_req, result);
  }
  
  /**
--- 1585,1591 ----
  			s3c_hsotg_send_zlp(hsotg, hs_req);
  	}
  
+ 	s3c_hsotg_complete_request(hsotg, hs_ep, hs_req, result);
  }
  
  /**
***************
*** 1856,1862 ****
  	/* Finish ZLP handling for IN EP0 transactions */
  	if (hsotg->eps[0].sent_zlp) {
  		dev_dbg(hsotg->dev, "zlp packet received\n");
- 		s3c_hsotg_complete_request_lock(hsotg, hs_ep, hs_req, 0);
  		return;
  	}
  
--- 1840,1846 ----
  	/* Finish ZLP handling for IN EP0 transactions */
  	if (hsotg->eps[0].sent_zlp) {
  		dev_dbg(hsotg->dev, "zlp packet received\n");
+ 		s3c_hsotg_complete_request(hsotg, hs_ep, hs_req, 0);
  		return;
  	}
  
***************
*** 1907,1913 ****
  		dev_dbg(hsotg->dev, "%s trying more for req...\n", __func__);
  		s3c_hsotg_start_req(hsotg, hs_ep, hs_req, true);
  	} else
- 		s3c_hsotg_complete_request_lock(hsotg, hs_ep, hs_req, 0);
  }
  
  /**
--- 1891,1897 ----
  		dev_dbg(hsotg->dev, "%s trying more for req...\n", __func__);
  		s3c_hsotg_start_req(hsotg, hs_ep, hs_req, true);
  	} else
+ 		s3c_hsotg_complete_request(hsotg, hs_ep, hs_req, 0);
  }
  
  /**
***************
*** 2115,2123 ****
  			      int result, bool force)
  {
  	struct s3c_hsotg_req *req, *treq;
- 	unsigned long flags;
- 
- 	spin_lock_irqsave(&ep->lock, flags);
  
  	list_for_each_entry_safe(req, treq, &ep->queue, queue) {
  		/*
--- 2099,2104 ----
  			      int result, bool force)
  {
  	struct s3c_hsotg_req *req, *treq;
  
  	list_for_each_entry_safe(req, treq, &ep->queue, queue) {
  		/*
***************
*** 2131,2144 ****
  		s3c_hsotg_complete_request(hsotg, ep, req,
  					   result);
  	}
- 
- 	spin_unlock_irqrestore(&ep->lock, flags);
  }
  
  #define call_gadget(_hs, _entry) \
  	if ((_hs)->gadget.speed != USB_SPEED_UNKNOWN &&	\
- 	    (_hs)->driver && (_hs)->driver->_entry)	\
- 		(_hs)->driver->_entry(&(_hs)->gadget);
  
  /**
   * s3c_hsotg_disconnect - disconnect service
--- 2112,2126 ----
  		s3c_hsotg_complete_request(hsotg, ep, req,
  					   result);
  	}
  }
  
  #define call_gadget(_hs, _entry) \
  	if ((_hs)->gadget.speed != USB_SPEED_UNKNOWN &&	\
+ 	    (_hs)->driver && (_hs)->driver->_entry) { \
+ 		spin_unlock(&_hs->lock); \
+ 		(_hs)->driver->_entry(&(_hs)->gadget); \
+ 		spin_lock(&_hs->lock); \
+ 		}
  
  /**
   * s3c_hsotg_disconnect - disconnect service
***************
*** 2380,2385 ****
  	u32 gintsts;
  	u32 gintmsk;
  
  irq_retry:
  	gintsts = readl(hsotg->regs + GINTSTS);
  	gintmsk = readl(hsotg->regs + GINTMSK);
--- 2362,2368 ----
  	u32 gintsts;
  	u32 gintmsk;
  
+ 	spin_lock(&hsotg->lock);
  irq_retry:
  	gintsts = readl(hsotg->regs + GINTSTS);
  	gintmsk = readl(hsotg->regs + GINTMSK);
***************
*** 2549,2554 ****
  	if (gintsts & IRQ_RETRY_MASK && --retry_count > 0)
  			goto irq_retry;
  
  	return IRQ_HANDLED;
  }
  
--- 2532,2539 ----
  	if (gintsts & IRQ_RETRY_MASK && --retry_count > 0)
  			goto irq_retry;
  
+ 	spin_unlock(&hsotg->lock);
+ 
  	return IRQ_HANDLED;
  }
  
***************
*** 2596,2602 ****
  	dev_dbg(hsotg->dev, "%s: read DxEPCTL=0x%08x from 0x%08x\n",
  		__func__, epctrl, epctrl_reg);
  
- 	spin_lock_irqsave(&hs_ep->lock, flags);
  
  	epctrl &= ~(DxEPCTL_EPType_MASK | DxEPCTL_MPS_MASK);
  	epctrl |= DxEPCTL_MPS(mps);
--- 2581,2587 ----
  	dev_dbg(hsotg->dev, "%s: read DxEPCTL=0x%08x from 0x%08x\n",
  		__func__, epctrl, epctrl_reg);
  
+ 	spin_lock_irqsave(&hsotg->lock, flags);
  
  	epctrl &= ~(DxEPCTL_EPType_MASK | DxEPCTL_MPS_MASK);
  	epctrl |= DxEPCTL_MPS(mps);
***************
*** 2675,2681 ****
  	s3c_hsotg_ctrl_epint(hsotg, index, dir_in, 1);
  
  out:
- 	spin_unlock_irqrestore(&hs_ep->lock, flags);
  	return ret;
  }
  
--- 2660,2666 ----
  	s3c_hsotg_ctrl_epint(hsotg, index, dir_in, 1);
  
  out:
+ 	spin_unlock_irqrestore(&hsotg->lock, flags);
  	return ret;
  }
  
***************
*** 2702,2711 ****
  
  	epctrl_reg = dir_in ? DIEPCTL(index) : DOEPCTL(index);
  
  	/* terminate all requests with shutdown */
  	kill_all_requests(hsotg, hs_ep, -ESHUTDOWN, false);
  
- 	spin_lock_irqsave(&hs_ep->lock, flags);
  
  	ctrl = readl(hsotg->regs + epctrl_reg);
  	ctrl &= ~DxEPCTL_EPEna;
--- 2687,2696 ----
  
  	epctrl_reg = dir_in ? DIEPCTL(index) : DOEPCTL(index);
  
+ 	spin_lock_irqsave(&hsotg->lock, flags);
  	/* terminate all requests with shutdown */
  	kill_all_requests(hsotg, hs_ep, -ESHUTDOWN, false);
  
  
  	ctrl = readl(hsotg->regs + epctrl_reg);
  	ctrl &= ~DxEPCTL_EPEna;
***************
*** 2718,2724 ****
  	/* disable endpoint interrupts */
  	s3c_hsotg_ctrl_epint(hsotg, hs_ep->index, hs_ep->dir_in, 0);
  
- 	spin_unlock_irqrestore(&hs_ep->lock, flags);
  	return 0;
  }
  
--- 2703,2709 ----
  	/* disable endpoint interrupts */
  	s3c_hsotg_ctrl_epint(hsotg, hs_ep->index, hs_ep->dir_in, 0);
  
+ 	spin_unlock_irqrestore(&hsotg->lock, flags);
  	return 0;
  }
  
***************
*** 2753,2767 ****
  
  	dev_info(hs->dev, "ep_dequeue(%p,%p)\n", ep, req);
  
- 	spin_lock_irqsave(&hs_ep->lock, flags);
  
  	if (!on_list(hs_ep, hs_req)) {
- 		spin_unlock_irqrestore(&hs_ep->lock, flags);
  		return -EINVAL;
  	}
  
  	s3c_hsotg_complete_request(hs, hs_ep, hs_req, -ECONNRESET);
- 	spin_unlock_irqrestore(&hs_ep->lock, flags);
  
  	return 0;
  }
--- 2738,2752 ----
  
  	dev_info(hs->dev, "ep_dequeue(%p,%p)\n", ep, req);
  
+ 	spin_lock_irqsave(&hs->lock, flags);
  
  	if (!on_list(hs_ep, hs_req)) {
+ 		spin_unlock_irqrestore(&hs->lock, flags);
  		return -EINVAL;
  	}
  
  	s3c_hsotg_complete_request(hs, hs_ep, hs_req, -ECONNRESET);
+ 	spin_unlock_irqrestore(&hs->lock, flags);
  
  	return 0;
  }
***************
*** 2776,2790 ****
  	struct s3c_hsotg_ep *hs_ep = our_ep(ep);
  	struct s3c_hsotg *hs = hs_ep->parent;
  	int index = hs_ep->index;
- 	unsigned long irqflags;
  	u32 epreg;
  	u32 epctl;
  	u32 xfertype;
  
  	dev_info(hs->dev, "%s(ep %p %s, %d)\n", __func__, ep, ep->name, value);
  
- 	spin_lock_irqsave(&hs_ep->lock, irqflags);
- 
  	/* write both IN and OUT control registers */
  
  	epreg = DIEPCTL(index);
--- 2761,2772 ----
  	struct s3c_hsotg_ep *hs_ep = our_ep(ep);
  	struct s3c_hsotg *hs = hs_ep->parent;
  	int index = hs_ep->index;
  	u32 epreg;
  	u32 epctl;
  	u32 xfertype;
  
  	dev_info(hs->dev, "%s(ep %p %s, %d)\n", __func__, ep, ep->name, value);
  
  	/* write both IN and OUT control registers */
  
  	epreg = DIEPCTL(index);
***************
*** 2819,2837 ****
  
  	writel(epctl, hs->regs + epreg);
  
- 	spin_unlock_irqrestore(&hs_ep->lock, irqflags);
- 
  	return 0;
  }
  
  static struct usb_ep_ops s3c_hsotg_ep_ops = {
  	.enable		= s3c_hsotg_ep_enable,
  	.disable	= s3c_hsotg_ep_disable,
  	.alloc_request	= s3c_hsotg_ep_alloc_request,
  	.free_request	= s3c_hsotg_ep_free_request,
- 	.queue		= s3c_hsotg_ep_queue,
  	.dequeue	= s3c_hsotg_ep_dequeue,
- 	.set_halt	= s3c_hsotg_ep_sethalt,
  	/* note, don't believe we have any call for the fifo routines */
  };
  
--- 2801,2836 ----
  
  	writel(epctl, hs->regs + epreg);
  
  	return 0;
  }
  
+ /**
+  * s3c_hsotg_ep_sethalt_lock - set halt on a given endpoint with lock held
+  * @ep: The endpoint to set halt.
+  * @value: Set or unset the halt.
+  */
+ static int s3c_hsotg_ep_sethalt_lock(struct usb_ep *ep, int value)
+ {
+ 	struct s3c_hsotg_ep *hs_ep = our_ep(ep);
+ 	struct s3c_hsotg *hs = hs_ep->parent;
+ 	unsigned long flags = 0;
+ 	int ret = 0;
+ 
+ 	spin_lock_irqsave(&hs->lock, flags);
+ 	ret = s3c_hsotg_ep_sethalt(ep, value);
+ 	spin_unlock_irqrestore(&hs->lock, flags);
+ 
+ 	return ret;
+ }
+ 
  static struct usb_ep_ops s3c_hsotg_ep_ops = {
  	.enable		= s3c_hsotg_ep_enable,
  	.disable	= s3c_hsotg_ep_disable,
  	.alloc_request	= s3c_hsotg_ep_alloc_request,
  	.free_request	= s3c_hsotg_ep_free_request,
+ 	.queue		= s3c_hsotg_ep_queue_lock,
  	.dequeue	= s3c_hsotg_ep_dequeue,
+ 	.set_halt	= s3c_hsotg_ep_sethalt_lock,
  	/* note, don't believe we have any call for the fifo routines */
  };
  
***************
*** 2946,2951 ****
  	driver->driver.bus = NULL;
  	hsotg->driver = driver;
  	hsotg->gadget.dev.driver = &driver->driver;
  	hsotg->gadget.dev.dma_mask = hsotg->dev->dma_mask;
  	hsotg->gadget.speed = USB_SPEED_UNKNOWN;
  
--- 2945,2951 ----
  	driver->driver.bus = NULL;
  	hsotg->driver = driver;
  	hsotg->gadget.dev.driver = &driver->driver;
+ 	hsotg->gadget.dev.of_node = hsotg->dev->of_node;
  	hsotg->gadget.dev.dma_mask = hsotg->dev->dma_mask;
  	hsotg->gadget.speed = USB_SPEED_UNKNOWN;
  
***************
*** 2956,2964 ****
  		goto err;
  	}
  
- 	s3c_hsotg_phy_enable(hsotg);
- 
- 	s3c_hsotg_core_init(hsotg);
  	hsotg->last_rst = jiffies;
  	dev_info(hsotg->dev, "bound driver %s\n", driver->driver.name);
  	return 0;
--- 2956,2961 ----
  		goto err;
  	}
  
  	hsotg->last_rst = jiffies;
  	dev_info(hsotg->dev, "bound driver %s\n", driver->driver.name);
  	return 0;
***************
*** 2980,2985 ****
  			  struct usb_gadget_driver *driver)
  {
  	struct s3c_hsotg *hsotg = to_hsotg(gadget);
  	int ep;
  
  	if (!hsotg)
--- 2977,2983 ----
  			  struct usb_gadget_driver *driver)
  {
  	struct s3c_hsotg *hsotg = to_hsotg(gadget);
+ 	unsigned long flags = 0;
  	int ep;
  
  	if (!hsotg)
***************
*** 2992,2997 ****
  	for (ep = 0; ep < hsotg->num_of_eps; ep++)
  		s3c_hsotg_ep_disable(&hsotg->eps[ep].ep);
  
  	s3c_hsotg_phy_disable(hsotg);
  	regulator_bulk_disable(ARRAY_SIZE(hsotg->supplies), hsotg->supplies);
  
--- 2990,2997 ----
  	for (ep = 0; ep < hsotg->num_of_eps; ep++)
  		s3c_hsotg_ep_disable(&hsotg->eps[ep].ep);
  
+ 	spin_lock_irqsave(&hsotg->lock, flags);
+ 
  	s3c_hsotg_phy_disable(hsotg);
  	regulator_bulk_disable(ARRAY_SIZE(hsotg->supplies), hsotg->supplies);
  
***************
*** 2999,3004 ****
  	hsotg->gadget.speed = USB_SPEED_UNKNOWN;
  	hsotg->gadget.dev.driver = NULL;
  
  	dev_info(hsotg->dev, "unregistered gadget driver '%s'\n",
  		 driver->driver.name);
  
--- 2999,3006 ----
  	hsotg->gadget.speed = USB_SPEED_UNKNOWN;
  	hsotg->gadget.dev.driver = NULL;
  
+ 	spin_unlock_irqrestore(&hsotg->lock, flags);
+ 
  	dev_info(hsotg->dev, "unregistered gadget driver '%s'\n",
  		 driver->driver.name);
  
***************
*** 3016,3025 ****
  	return s3c_hsotg_read_frameno(to_hsotg(gadget));
  }
  
  static struct usb_gadget_ops s3c_hsotg_gadget_ops = {
  	.get_frame	= s3c_hsotg_gadget_getframe,
  	.udc_start		= s3c_hsotg_udc_start,
  	.udc_stop		= s3c_hsotg_udc_stop,
  };
  
  /**
--- 3018,3057 ----
  	return s3c_hsotg_read_frameno(to_hsotg(gadget));
  }
  
+ /**
+  * s3c_hsotg_pullup - connect/disconnect the USB PHY
+  * @gadget: The usb gadget state
+  * @is_on: Current state of the USB PHY
+  *
+  * Connect/Disconnect the USB PHY pullup
+  */
+ static int s3c_hsotg_pullup(struct usb_gadget *gadget, int is_on)
+ {
+ 	struct s3c_hsotg *hsotg = to_hsotg(gadget);
+ 	unsigned long flags = 0;
+ 
+ 	dev_dbg(hsotg->dev, "%s: is_in: %d\n", __func__, is_on);
+ 
+ 	spin_lock_irqsave(&hsotg->lock, flags);
+ 	if (is_on) {
+ 		s3c_hsotg_phy_enable(hsotg);
+ 		s3c_hsotg_core_init(hsotg);
+ 	} else {
+ 		s3c_hsotg_disconnect(hsotg);
+ 		s3c_hsotg_phy_disable(hsotg);
+ 	}
+ 
+ 	hsotg->gadget.speed = USB_SPEED_UNKNOWN;
+ 	spin_unlock_irqrestore(&hsotg->lock, flags);
+ 
+ 	return 0;
+ }
+ 
  static struct usb_gadget_ops s3c_hsotg_gadget_ops = {
  	.get_frame	= s3c_hsotg_gadget_getframe,
  	.udc_start		= s3c_hsotg_udc_start,
  	.udc_stop		= s3c_hsotg_udc_stop,
+ 	.pullup                 = s3c_hsotg_pullup,
  };
  
  /**
***************
*** 3055,3062 ****
  	INIT_LIST_HEAD(&hs_ep->queue);
  	INIT_LIST_HEAD(&hs_ep->ep.ep_list);
  
- 	spin_lock_init(&hs_ep->lock);
- 
  	/* add to the list of endpoints known by the gadget driver */
  	if (epnum)
  		list_add_tail(&hs_ep->ep.ep_list, &hsotg->gadget.ep_list);
--- 3087,3092 ----
  	INIT_LIST_HEAD(&hs_ep->queue);
  	INIT_LIST_HEAD(&hs_ep->ep.ep_list);
  
  	/* add to the list of endpoints known by the gadget driver */
  	if (epnum)
  		list_add_tail(&hs_ep->ep.ep_list, &hsotg->gadget.ep_list);
***************
*** 3334,3340 ****
  	seq_printf(seq, "request list (%p,%p):\n",
  		   ep->queue.next, ep->queue.prev);
  
- 	spin_lock_irqsave(&ep->lock, flags);
  
  	list_for_each_entry(req, &ep->queue, queue) {
  		if (--show_limit < 0) {
--- 3364,3370 ----
  	seq_printf(seq, "request list (%p,%p):\n",
  		   ep->queue.next, ep->queue.prev);
  
+ 	spin_lock_irqsave(&hsotg->lock, flags);
  
  	list_for_each_entry(req, &ep->queue, queue) {
  		if (--show_limit < 0) {
***************
*** 3349,3355 ****
  			   req->req.actual, req->req.status);
  	}
  
- 	spin_unlock_irqrestore(&ep->lock, flags);
  
  	return 0;
  }
--- 3379,3385 ----
  			   req->req.actual, req->req.status);
  	}
  
+ 	spin_unlock_irqrestore(&hsotg->lock, flags);
  
  	return 0;
  }
***************
*** 3469,3475 ****
  		return -EINVAL;
  	}
  
- 	hsotg = kzalloc(sizeof(struct s3c_hsotg), GFP_KERNEL);
  	if (!hsotg) {
  		dev_err(dev, "cannot get memory\n");
  		return -ENOMEM;
--- 3499,3505 ----
  		return -EINVAL;
  	}
  
+ 	hsotg = devm_kzalloc(&pdev->dev, sizeof(struct s3c_hsotg), GFP_KERNEL);
  	if (!hsotg) {
  		dev_err(dev, "cannot get memory\n");
  		return -ENOMEM;
***************
*** 3481,3526 ****
  	hsotg->clk = clk_get(&pdev->dev, "otg");
  	if (IS_ERR(hsotg->clk)) {
  		dev_err(dev, "cannot get otg clock\n");
- 		ret = PTR_ERR(hsotg->clk);
- 		goto err_mem;
  	}
  
  	platform_set_drvdata(pdev, hsotg);
  
  	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
- 	if (!res) {
- 		dev_err(dev, "cannot find register resource 0\n");
- 		ret = -EINVAL;
- 		goto err_clk;
- 	}
- 
- 	hsotg->regs_res = request_mem_region(res->start, resource_size(res),
- 					     dev_name(dev));
- 	if (!hsotg->regs_res) {
- 		dev_err(dev, "cannot reserve registers\n");
- 		ret = -ENOENT;
- 		goto err_clk;
- 	}
  
- 	hsotg->regs = ioremap(res->start, resource_size(res));
  	if (!hsotg->regs) {
  		dev_err(dev, "cannot map registers\n");
  		ret = -ENXIO;
- 		goto err_regs_res;
  	}
  
  	ret = platform_get_irq(pdev, 0);
  	if (ret < 0) {
  		dev_err(dev, "cannot find IRQ\n");
- 		goto err_regs;
  	}
  
  	hsotg->irq = ret;
  
- 	ret = request_irq(ret, s3c_hsotg_irq, 0, dev_name(dev), hsotg);
  	if (ret < 0) {
  		dev_err(dev, "cannot claim IRQ\n");
- 		goto err_regs;
  	}
  
  	dev_info(dev, "regs %p, irq %d\n", hsotg->regs, hsotg->irq);
--- 3511,3545 ----
  	hsotg->clk = clk_get(&pdev->dev, "otg");
  	if (IS_ERR(hsotg->clk)) {
  		dev_err(dev, "cannot get otg clock\n");
+ 		return PTR_ERR(hsotg->clk);
  	}
  
  	platform_set_drvdata(pdev, hsotg);
  
  	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
  
+ 	hsotg->regs = devm_request_and_ioremap(&pdev->dev, res);
  	if (!hsotg->regs) {
  		dev_err(dev, "cannot map registers\n");
  		ret = -ENXIO;
+ 		goto err_clk;
  	}
  
  	ret = platform_get_irq(pdev, 0);
  	if (ret < 0) {
  		dev_err(dev, "cannot find IRQ\n");
+ 		goto err_clk;
  	}
  
+ 	spin_lock_init(&hsotg->lock);
+ 
  	hsotg->irq = ret;
  
+ 	ret = devm_request_irq(&pdev->dev, hsotg->irq, s3c_hsotg_irq, 0,
+ 				dev_name(dev), hsotg);
  	if (ret < 0) {
  		dev_err(dev, "cannot claim IRQ\n");
+ 		goto err_clk;
  	}
  
  	dev_info(dev, "regs %p, irq %d\n", hsotg->regs, hsotg->irq);
***************
*** 3550,3556 ****
  				 hsotg->supplies);
  	if (ret) {
  		dev_err(dev, "failed to request supplies: %d\n", ret);
- 		goto err_irq;
  	}
  
  	ret = regulator_bulk_enable(ARRAY_SIZE(hsotg->supplies),
--- 3569,3575 ----
  				 hsotg->supplies);
  	if (ret) {
  		dev_err(dev, "failed to request supplies: %d\n", ret);
+ 		goto err_clk;
  	}
  
  	ret = regulator_bulk_enable(ARRAY_SIZE(hsotg->supplies),
***************
*** 3572,3577 ****
  
  	if (hsotg->num_of_eps == 0) {
  		dev_err(dev, "wrong number of EPs (zero)\n");
  		goto err_supplies;
  	}
  
--- 3591,3597 ----
  
  	if (hsotg->num_of_eps == 0) {
  		dev_err(dev, "wrong number of EPs (zero)\n");
+ 		ret = -EINVAL;
  		goto err_supplies;
  	}
  
***************
*** 3579,3584 ****
  		      GFP_KERNEL);
  	if (!eps) {
  		dev_err(dev, "cannot get memory\n");
  		goto err_supplies;
  	}
  
--- 3599,3605 ----
  		      GFP_KERNEL);
  	if (!eps) {
  		dev_err(dev, "cannot get memory\n");
+ 		ret = -ENOMEM;
  		goto err_supplies;
  	}
  
***************
*** 3595,3600 ****
  						     GFP_KERNEL);
  	if (!hsotg->ctrl_req) {
  		dev_err(dev, "failed to allocate ctrl req\n");
  		goto err_ep_mem;
  	}
  
--- 3616,3622 ----
  						     GFP_KERNEL);
  	if (!hsotg->ctrl_req) {
  		dev_err(dev, "failed to allocate ctrl req\n");
+ 		ret = -ENOMEM;
  		goto err_ep_mem;
  	}
  
***************
*** 3634,3652 ****
  err_supplies:
  	s3c_hsotg_phy_disable(hsotg);
  	regulator_bulk_free(ARRAY_SIZE(hsotg->supplies), hsotg->supplies);
- err_irq:
- 	free_irq(hsotg->irq, hsotg);
- err_regs:
- 	iounmap(hsotg->regs);
- 
- err_regs_res:
- 	release_resource(hsotg->regs_res);
- 	kfree(hsotg->regs_res);
  err_clk:
  	clk_disable_unprepare(hsotg->clk);
  	clk_put(hsotg->clk);
- err_mem:
- 	kfree(hsotg);
  	return ret;
  }
  
--- 3656,3666 ----
  err_supplies:
  	s3c_hsotg_phy_disable(hsotg);
  	regulator_bulk_free(ARRAY_SIZE(hsotg->supplies), hsotg->supplies);
+ 
  err_clk:
  	clk_disable_unprepare(hsotg->clk);
  	clk_put(hsotg->clk);
+ 
  	return ret;
  }
  
***************
*** 3667,3678 ****
  		usb_gadget_unregister_driver(hsotg->driver);
  	}
  
- 	free_irq(hsotg->irq, hsotg);
- 	iounmap(hsotg->regs);
- 
- 	release_resource(hsotg->regs_res);
- 	kfree(hsotg->regs_res);
- 
  	s3c_hsotg_phy_disable(hsotg);
  	regulator_bulk_free(ARRAY_SIZE(hsotg->supplies), hsotg->supplies);
  
--- 3681,3686 ----
  		usb_gadget_unregister_driver(hsotg->driver);
  	}
  
  	s3c_hsotg_phy_disable(hsotg);
  	regulator_bulk_free(ARRAY_SIZE(hsotg->supplies), hsotg->supplies);
  
