***************
*** 27,36 ****
  #include <linux/platform_device.h>
  #include <linux/pm_runtime.h>
  #include <linux/spi/spi.h>
  
  #include <mach/dma.h>
  #include <plat/s3c64xx-spi.h>
  
  /* Registers and bit-fields */
  
  #define S3C64XX_SPI_CH_CFG		0x00
--- 27,41 ----
  #include <linux/platform_device.h>
  #include <linux/pm_runtime.h>
  #include <linux/spi/spi.h>
+ #include <linux/gpio.h>
+ #include <linux/of.h>
+ #include <linux/of_gpio.h>
  
  #include <mach/dma.h>
  #include <plat/s3c64xx-spi.h>
  
+ #define MAX_SPI_PORTS		3
+ 
  /* Registers and bit-fields */
  
  #define S3C64XX_SPI_CH_CFG		0x00
***************
*** 74,84 ****
  #define S3C64XX_SPI_SLAVE_AUTO			(1<<1)
  #define S3C64XX_SPI_SLAVE_SIG_INACT		(1<<0)
  
- #define S3C64XX_SPI_ACT(c) writel(0, (c)->regs + S3C64XX_SPI_SLAVE_SEL)
- 
- #define S3C64XX_SPI_DEACT(c) writel(S3C64XX_SPI_SLAVE_SIG_INACT, \
- 					(c)->regs + S3C64XX_SPI_SLAVE_SEL)
- 
  #define S3C64XX_SPI_INT_TRAILING_EN		(1<<6)
  #define S3C64XX_SPI_INT_RX_OVERRUN_EN		(1<<5)
  #define S3C64XX_SPI_INT_RX_UNDERRUN_EN		(1<<4)
--- 79,84 ----
  #define S3C64XX_SPI_SLAVE_AUTO			(1<<1)
  #define S3C64XX_SPI_SLAVE_SIG_INACT		(1<<0)
  
  #define S3C64XX_SPI_INT_TRAILING_EN		(1<<6)
  #define S3C64XX_SPI_INT_RX_OVERRUN_EN		(1<<5)
  #define S3C64XX_SPI_INT_RX_UNDERRUN_EN		(1<<4)
***************
*** 113,125 ****
  
  #define S3C64XX_SPI_FBCLK_MSK		(3<<0)
  
- #define S3C64XX_SPI_ST_TRLCNTZ(v, i) ((((v) >> (i)->rx_lvl_offset) & \
- 					(((i)->fifo_lvl_mask + 1))) \
- 					? 1 : 0)
- 
- #define S3C64XX_SPI_ST_TX_DONE(v, i) (((v) & (1 << (i)->tx_st_done)) ? 1 : 0)
- #define TX_FIFO_LVL(v, i) (((v) >> 6) & (i)->fifo_lvl_mask)
- #define RX_FIFO_LVL(v, i) (((v) >> (i)->rx_lvl_offset) & (i)->fifo_lvl_mask)
  
  #define S3C64XX_SPI_MAX_TRAILCNT	0x3ff
  #define S3C64XX_SPI_TRAILCNT_OFF	19
--- 113,124 ----
  
  #define S3C64XX_SPI_FBCLK_MSK		(3<<0)
  
+ #define FIFO_LVL_MASK(i) ((i)->port_conf->fifo_lvl_mask[i->port_id])
+ #define S3C64XX_SPI_ST_TX_DONE(v, i) (((v) & \
+ 				(1 << (i)->port_conf->tx_st_done)) ? 1 : 0)
+ #define TX_FIFO_LVL(v, i) (((v) >> 6) & FIFO_LVL_MASK(i))
+ #define RX_FIFO_LVL(v, i) (((v) >> (i)->port_conf->rx_lvl_offset) & \
+ 					FIFO_LVL_MASK(i))
  
  #define S3C64XX_SPI_MAX_TRAILCNT	0x3ff
  #define S3C64XX_SPI_TRAILCNT_OFF	19
***************
*** 135,140 ****
  	unsigned		ch;
  	enum dma_data_direction direction;
  	enum dma_ch	dmach;
  };
  
  /**
--- 134,162 ----
  	unsigned		ch;
  	enum dma_data_direction direction;
  	enum dma_ch	dmach;
+ 	struct property		*dma_prop;
+ };
+ 
+ /**
+  * struct s3c64xx_spi_info - SPI Controller hardware info
+  * @fifo_lvl_mask: Bit-mask for {TX|RX}_FIFO_LVL bits in SPI_STATUS register.
+  * @rx_lvl_offset: Bit offset of RX_FIFO_LVL bits in SPI_STATUS regiter.
+  * @tx_st_done: Bit offset of TX_DONE bit in SPI_STATUS regiter.
+  * @high_speed: True, if the controller supports HIGH_SPEED_EN bit.
+  * @clk_from_cmu: True, if the controller does not include a clock mux and
+  *	prescaler unit.
+  *
+  * The Samsung s3c64xx SPI controller are used on various Samsung SoC's but
+  * differ in some aspects such as the size of the fifo and spi bus clock
+  * setup. Such differences are specified to the driver using this structure
+  * which is provided as driver data to the driver.
+  */
+ struct s3c64xx_spi_port_config {
+ 	int	fifo_lvl_mask[MAX_SPI_PORTS];
+ 	int	rx_lvl_offset;
+ 	int	tx_st_done;
+ 	bool	high_speed;
+ 	bool	clk_from_cmu;
  };
  
  /**
***************
*** 175,180 ****
  	struct s3c64xx_spi_dma_data	rx_dma;
  	struct s3c64xx_spi_dma_data	tx_dma;
  	struct samsung_dma_ops		*ops;
  };
  
  static struct s3c2410_dma_client s3c64xx_spi_dma_client = {
--- 197,205 ----
  	struct s3c64xx_spi_dma_data	rx_dma;
  	struct s3c64xx_spi_dma_data	tx_dma;
  	struct samsung_dma_ops		*ops;
+ 	struct s3c64xx_spi_port_config	*port_conf;
+ 	unsigned int			port_id;
+ 	unsigned long			gpios[4];
  };
  
  static struct s3c2410_dma_client s3c64xx_spi_dma_client = {
***************
*** 183,189 ****
  
  static void flush_fifo(struct s3c64xx_spi_driver_data *sdd)
  {
- 	struct s3c64xx_spi_info *sci = sdd->cntrlr_info;
  	void __iomem *regs = sdd->regs;
  	unsigned long loops;
  	u32 val;
--- 208,213 ----
  
  static void flush_fifo(struct s3c64xx_spi_driver_data *sdd)
  {
  	void __iomem *regs = sdd->regs;
  	unsigned long loops;
  	u32 val;
***************
*** 199,205 ****
  	loops = msecs_to_loops(1);
  	do {
  		val = readl(regs + S3C64XX_SPI_STATUS);
- 	} while (TX_FIFO_LVL(val, sci) && loops--);
  
  	if (loops == 0)
  		dev_warn(&sdd->pdev->dev, "Timed out flushing TX FIFO\n");
--- 223,229 ----
  	loops = msecs_to_loops(1);
  	do {
  		val = readl(regs + S3C64XX_SPI_STATUS);
+ 	} while (TX_FIFO_LVL(val, sdd) && loops--);
  
  	if (loops == 0)
  		dev_warn(&sdd->pdev->dev, "Timed out flushing TX FIFO\n");
***************
*** 208,214 ****
  	loops = msecs_to_loops(1);
  	do {
  		val = readl(regs + S3C64XX_SPI_STATUS);
- 		if (RX_FIFO_LVL(val, sci))
  			readl(regs + S3C64XX_SPI_RX_DATA);
  		else
  			break;
--- 232,238 ----
  	loops = msecs_to_loops(1);
  	do {
  		val = readl(regs + S3C64XX_SPI_STATUS);
+ 		if (RX_FIFO_LVL(val, sdd))
  			readl(regs + S3C64XX_SPI_RX_DATA);
  		else
  			break;
***************
*** 262,275 ****
  					unsigned len, dma_addr_t buf)
  {
  	struct s3c64xx_spi_driver_data *sdd;
- 	struct samsung_dma_prep_info info;
  
- 	if (dma->direction == DMA_DEV_TO_MEM)
  		sdd = container_of((void *)dma,
  			struct s3c64xx_spi_driver_data, rx_dma);
- 	else
  		sdd = container_of((void *)dma,
  			struct s3c64xx_spi_driver_data, tx_dma);
  
  	info.cap = DMA_SLAVE;
  	info.len = len;
--- 286,309 ----
  					unsigned len, dma_addr_t buf)
  {
  	struct s3c64xx_spi_driver_data *sdd;
+ 	struct samsung_dma_prep info;
+ 	struct samsung_dma_config config;
  
+ 	if (dma->direction == DMA_DEV_TO_MEM) {
  		sdd = container_of((void *)dma,
  			struct s3c64xx_spi_driver_data, rx_dma);
+ 		config.direction = sdd->rx_dma.direction;
+ 		config.fifo = sdd->sfr_start + S3C64XX_SPI_RX_DATA;
+ 		config.width = sdd->cur_bpw / 8;
+ 		sdd->ops->config(sdd->rx_dma.ch, &config);
+ 	} else {
  		sdd = container_of((void *)dma,
  			struct s3c64xx_spi_driver_data, tx_dma);
+ 		config.direction =  sdd->tx_dma.direction;
+ 		config.fifo = sdd->sfr_start + S3C64XX_SPI_TX_DATA;
+ 		config.width = sdd->cur_bpw / 8;
+ 		sdd->ops->config(sdd->tx_dma.ch, &config);
+ 	}
  
  	info.cap = DMA_SLAVE;
  	info.len = len;
***************
*** 284,303 ****
  
  static int acquire_dma(struct s3c64xx_spi_driver_data *sdd)
  {
- 	struct samsung_dma_info info;
  
  	sdd->ops = samsung_dma_get_ops();
  
- 	info.cap = DMA_SLAVE;
- 	info.client = &s3c64xx_spi_dma_client;
- 	info.width = sdd->cur_bpw / 8;
  
- 	info.direction = sdd->rx_dma.direction;
- 	info.fifo = sdd->sfr_start + S3C64XX_SPI_RX_DATA;
- 	sdd->rx_dma.ch = sdd->ops->request(sdd->rx_dma.dmach, &info);
- 	info.direction =  sdd->tx_dma.direction;
- 	info.fifo = sdd->sfr_start + S3C64XX_SPI_TX_DATA;
- 	sdd->tx_dma.ch = sdd->ops->request(sdd->tx_dma.dmach, &info);
  
  	return 1;
  }
--- 318,334 ----
  
  static int acquire_dma(struct s3c64xx_spi_driver_data *sdd)
  {
+ 	struct samsung_dma_req req;
  
  	sdd->ops = samsung_dma_get_ops();
  
+ 	req.cap = DMA_SLAVE;
+ 	req.client = &s3c64xx_spi_dma_client;
  
+ 	req.dt_dmach_prop = sdd->rx_dma.dma_prop;
+ 	sdd->rx_dma.ch = sdd->ops->request(sdd->rx_dma.dmach, &req);
+ 	req.dt_dmach_prop = sdd->tx_dma.dma_prop;
+ 	sdd->tx_dma.ch = sdd->ops->request(sdd->tx_dma.dmach, &req);
  
  	return 1;
  }
***************
*** 306,312 ****
  				struct spi_device *spi,
  				struct spi_transfer *xfer, int dma_mode)
  {
- 	struct s3c64xx_spi_info *sci = sdd->cntrlr_info;
  	void __iomem *regs = sdd->regs;
  	u32 modecfg, chcfg;
  
--- 337,342 ----
  				struct spi_device *spi,
  				struct spi_transfer *xfer, int dma_mode)
  {
  	void __iomem *regs = sdd->regs;
  	u32 modecfg, chcfg;
  
***************
*** 356,362 ****
  	if (xfer->rx_buf != NULL) {
  		sdd->state |= RXBUSY;
  
- 		if (sci->high_speed && sdd->cur_speed >= 30000000UL
  					&& !(sdd->cur_mode & SPI_CPHA))
  			chcfg |= S3C64XX_SPI_CH_HS_EN;
  
--- 386,392 ----
  	if (xfer->rx_buf != NULL) {
  		sdd->state |= RXBUSY;
  
+ 		if (sdd->port_conf->high_speed && sdd->cur_speed >= 30000000UL
  					&& !(sdd->cur_mode & SPI_CPHA))
  			chcfg |= S3C64XX_SPI_CH_HS_EN;
  
***************
*** 383,402 ****
  		if (sdd->tgl_spi != spi) { /* if last mssg on diff device */
  			/* Deselect the last toggled device */
  			cs = sdd->tgl_spi->controller_data;
- 			cs->set_level(cs->line,
- 					spi->mode & SPI_CS_HIGH ? 0 : 1);
  		}
  		sdd->tgl_spi = NULL;
  	}
  
  	cs = spi->controller_data;
- 	cs->set_level(cs->line, spi->mode & SPI_CS_HIGH ? 1 : 0);
  }
  
  static int wait_for_xfer(struct s3c64xx_spi_driver_data *sdd,
  				struct spi_transfer *xfer, int dma_mode)
  {
- 	struct s3c64xx_spi_info *sci = sdd->cntrlr_info;
  	void __iomem *regs = sdd->regs;
  	unsigned long val;
  	int ms;
--- 413,431 ----
  		if (sdd->tgl_spi != spi) { /* if last mssg on diff device */
  			/* Deselect the last toggled device */
  			cs = sdd->tgl_spi->controller_data;
+ 			gpio_set_value(cs->line,
+ 				spi->mode & SPI_CS_HIGH ? 0 : 1);
  		}
  		sdd->tgl_spi = NULL;
  	}
  
  	cs = spi->controller_data;
+ 	gpio_set_value(cs->line, spi->mode & SPI_CS_HIGH ? 1 : 0);
  }
  
  static int wait_for_xfer(struct s3c64xx_spi_driver_data *sdd,
  				struct spi_transfer *xfer, int dma_mode)
  {
  	void __iomem *regs = sdd->regs;
  	unsigned long val;
  	int ms;
***************
*** 413,419 ****
  		val = msecs_to_loops(ms);
  		do {
  			status = readl(regs + S3C64XX_SPI_STATUS);
- 		} while (RX_FIFO_LVL(status, sci) < xfer->len && --val);
  	}
  
  	if (!val)
--- 442,448 ----
  		val = msecs_to_loops(ms);
  		do {
  			status = readl(regs + S3C64XX_SPI_STATUS);
+ 		} while (RX_FIFO_LVL(status, sdd) < xfer->len && --val);
  	}
  
  	if (!val)
***************
*** 432,439 ****
  		if (xfer->rx_buf == NULL) {
  			val = msecs_to_loops(10);
  			status = readl(regs + S3C64XX_SPI_STATUS);
- 			while ((TX_FIFO_LVL(status, sci)
- 				|| !S3C64XX_SPI_ST_TX_DONE(status, sci))
  					&& --val) {
  				cpu_relax();
  				status = readl(regs + S3C64XX_SPI_STATUS);
--- 461,468 ----
  		if (xfer->rx_buf == NULL) {
  			val = msecs_to_loops(10);
  			status = readl(regs + S3C64XX_SPI_STATUS);
+ 			while ((TX_FIFO_LVL(status, sdd)
+ 				|| !S3C64XX_SPI_ST_TX_DONE(status, sdd))
  					&& --val) {
  				cpu_relax();
  				status = readl(regs + S3C64XX_SPI_STATUS);
***************
*** 477,493 ****
  	if (sdd->tgl_spi == spi)
  		sdd->tgl_spi = NULL;
  
- 	cs->set_level(cs->line, spi->mode & SPI_CS_HIGH ? 0 : 1);
  }
  
  static void s3c64xx_spi_config(struct s3c64xx_spi_driver_data *sdd)
  {
- 	struct s3c64xx_spi_info *sci = sdd->cntrlr_info;
  	void __iomem *regs = sdd->regs;
  	u32 val;
  
  	/* Disable Clock */
- 	if (sci->clk_from_cmu) {
  		clk_disable(sdd->src_clk);
  	} else {
  		val = readl(regs + S3C64XX_SPI_CLK_CFG);
--- 506,521 ----
  	if (sdd->tgl_spi == spi)
  		sdd->tgl_spi = NULL;
  
+ 	gpio_set_value(cs->line, spi->mode & SPI_CS_HIGH ? 0 : 1);
  }
  
  static void s3c64xx_spi_config(struct s3c64xx_spi_driver_data *sdd)
  {
  	void __iomem *regs = sdd->regs;
  	u32 val;
  
  	/* Disable Clock */
+ 	if (sdd->port_conf->clk_from_cmu) {
  		clk_disable(sdd->src_clk);
  	} else {
  		val = readl(regs + S3C64XX_SPI_CLK_CFG);
***************
*** 531,537 ****
  
  	writel(val, regs + S3C64XX_SPI_MODE_CFG);
  
- 	if (sci->clk_from_cmu) {
  		/* Configure Clock */
  		/* There is half-multiplier before the SPI */
  		clk_set_rate(sdd->src_clk, sdd->cur_speed * 2);
--- 559,565 ----
  
  	writel(val, regs + S3C64XX_SPI_MODE_CFG);
  
+ 	if (sdd->port_conf->clk_from_cmu) {
  		/* Configure Clock */
  		/* There is half-multiplier before the SPI */
  		clk_set_rate(sdd->src_clk, sdd->cur_speed * 2);
***************
*** 557,563 ****
  static int s3c64xx_spi_map_mssg(struct s3c64xx_spi_driver_data *sdd,
  						struct spi_message *msg)
  {
- 	struct s3c64xx_spi_info *sci = sdd->cntrlr_info;
  	struct device *dev = &sdd->pdev->dev;
  	struct spi_transfer *xfer;
  
--- 585,590 ----
  static int s3c64xx_spi_map_mssg(struct s3c64xx_spi_driver_data *sdd,
  						struct spi_message *msg)
  {
  	struct device *dev = &sdd->pdev->dev;
  	struct spi_transfer *xfer;
  
***************
*** 573,579 ****
  	/* Map until end or first fail */
  	list_for_each_entry(xfer, &msg->transfers, transfer_list) {
  
- 		if (xfer->len <= ((sci->fifo_lvl_mask >> 1) + 1))
  			continue;
  
  		if (xfer->tx_buf != NULL) {
--- 600,606 ----
  	/* Map until end or first fail */
  	list_for_each_entry(xfer, &msg->transfers, transfer_list) {
  
+ 		if (xfer->len <= ((FIFO_LVL_MASK(sdd) >> 1) + 1))
  			continue;
  
  		if (xfer->tx_buf != NULL) {
***************
*** 607,613 ****
  static void s3c64xx_spi_unmap_mssg(struct s3c64xx_spi_driver_data *sdd,
  						struct spi_message *msg)
  {
- 	struct s3c64xx_spi_info *sci = sdd->cntrlr_info;
  	struct device *dev = &sdd->pdev->dev;
  	struct spi_transfer *xfer;
  
--- 634,639 ----
  static void s3c64xx_spi_unmap_mssg(struct s3c64xx_spi_driver_data *sdd,
  						struct spi_message *msg)
  {
  	struct device *dev = &sdd->pdev->dev;
  	struct spi_transfer *xfer;
  
***************
*** 616,622 ****
  
  	list_for_each_entry(xfer, &msg->transfers, transfer_list) {
  
- 		if (xfer->len <= ((sci->fifo_lvl_mask >> 1) + 1))
  			continue;
  
  		if (xfer->rx_buf != NULL
--- 642,648 ----
  
  	list_for_each_entry(xfer, &msg->transfers, transfer_list) {
  
+ 		if (xfer->len <= ((FIFO_LVL_MASK(sdd) >> 1) + 1))
  			continue;
  
  		if (xfer->rx_buf != NULL
***************
*** 635,641 ****
  					    struct spi_message *msg)
  {
  	struct s3c64xx_spi_driver_data *sdd = spi_master_get_devdata(master);
- 	struct s3c64xx_spi_info *sci = sdd->cntrlr_info;
  	struct spi_device *spi = msg->spi;
  	struct s3c64xx_spi_csinfo *cs = spi->controller_data;
  	struct spi_transfer *xfer;
--- 661,666 ----
  					    struct spi_message *msg)
  {
  	struct s3c64xx_spi_driver_data *sdd = spi_master_get_devdata(master);
  	struct spi_device *spi = msg->spi;
  	struct s3c64xx_spi_csinfo *cs = spi->controller_data;
  	struct spi_transfer *xfer;
***************
*** 690,696 ****
  		}
  
  		/* Polling method for xfers not bigger than FIFO capacity */
- 		if (xfer->len <= ((sci->fifo_lvl_mask >> 1) + 1))
  			use_dma = 0;
  		else
  			use_dma = 1;
--- 715,721 ----
  		}
  
  		/* Polling method for xfers not bigger than FIFO capacity */
+ 		if (xfer->len <= ((FIFO_LVL_MASK(sdd) >> 1) + 1))
  			use_dma = 0;
  		else
  			use_dma = 1;
***************
*** 707,720 ****
  		enable_cs(sdd, spi);
  
  		/* Start the signals */
- 		S3C64XX_SPI_ACT(sdd);
  
  		spin_unlock_irqrestore(&sdd->lock, flags);
  
  		status = wait_for_xfer(sdd, xfer, use_dma);
  
  		/* Quiese the signals */
- 		S3C64XX_SPI_DEACT(sdd);
  
  		if (status) {
  			dev_err(&spi->dev, "I/O Error: "
--- 732,746 ----
  		enable_cs(sdd, spi);
  
  		/* Start the signals */
+ 		writel(0, sdd->regs + S3C64XX_SPI_SLAVE_SEL);
  
  		spin_unlock_irqrestore(&sdd->lock, flags);
  
  		status = wait_for_xfer(sdd, xfer, use_dma);
  
  		/* Quiese the signals */
+ 		writel(S3C64XX_SPI_SLAVE_SIG_INACT,
+ 		       sdd->regs + S3C64XX_SPI_SLAVE_SEL);
  
  		if (status) {
  			dev_err(&spi->dev, "I/O Error: "
***************
*** 795,800 ****
  	return 0;
  }
  
  /*
   * Here we only check the validity of requested configuration
   * and save the configuration in a local data-structure.
--- 821,868 ----
  	return 0;
  }
  
+ static struct s3c64xx_spi_csinfo *s3c64xx_get_slave_ctrldata(
+ 				struct s3c64xx_spi_driver_data *sdd,
+ 				struct spi_device *spi)
+ {
+ 	struct s3c64xx_spi_csinfo *cs;
+ 	struct device_node *slave_np, *data_np = NULL;
+ 	u32 fb_delay = 0;
+ 
+ 	slave_np = spi->dev.of_node;
+ 	if (!slave_np) {
+ 		dev_err(&spi->dev, "device node not found\n");
+ 		return ERR_PTR(-EINVAL);
+ 	}
+ 
+ 	for_each_child_of_node(slave_np, data_np)
+ 		if (!strcmp(data_np->name, "controller-data"))
+ 			break;
+ 	if (!data_np) {
+ 		dev_err(&spi->dev, "child node 'controller-data' not found\n");
+ 		return ERR_PTR(-EINVAL);
+ 	}
+ 
+ 	cs = kzalloc(sizeof(*cs), GFP_KERNEL);
+ 	if (!cs) {
+ 		dev_err(&spi->dev, "could not allocate memory for controller"
+ 					" data\n");
+ 		return ERR_PTR(-ENOMEM);
+ 	}
+ 
+ 	cs->line = of_get_named_gpio(data_np, "cs-gpio", 0);
+ 	if (!gpio_is_valid(cs->line)) {
+ 		dev_err(&spi->dev, "chip select gpio is not specified or "
+ 					"invalid\n");
+ 		kfree(cs);
+ 		return ERR_PTR(-EINVAL);
+ 	}
+ 
+ 	of_property_read_u32(data_np, "samsung,spi-feedback-delay", &fb_delay);
+ 	cs->fb_delay = fb_delay;
+ 	return cs;
+ }
+ 
  /*
   * Here we only check the validity of requested configuration
   * and save the configuration in a local data-structure.
***************
*** 808,821 ****
  	struct s3c64xx_spi_info *sci;
  	struct spi_message *msg;
  	unsigned long flags;
- 	int err = 0;
  
- 	if (cs == NULL || cs->set_level == NULL) {
  		dev_err(&spi->dev, "No CS for SPI(%d)\n", spi->chip_select);
  		return -ENODEV;
  	}
  
- 	sdd = spi_master_get_devdata(spi->master);
  	sci = sdd->cntrlr_info;
  
  	spin_lock_irqsave(&sdd->lock, flags);
--- 876,906 ----
  	struct s3c64xx_spi_info *sci;
  	struct spi_message *msg;
  	unsigned long flags;
+ 	int err;
  
+ 	sdd = spi_master_get_devdata(spi->master);
+ 	if (!cs && spi->dev.of_node) {
+ 		cs = s3c64xx_get_slave_ctrldata(sdd, spi);
+ 		spi->controller_data = cs;
+ 	}
+ 
+ 	if (IS_ERR_OR_NULL(cs)) {
  		dev_err(&spi->dev, "No CS for SPI(%d)\n", spi->chip_select);
  		return -ENODEV;
  	}
  
+ 	if (!spi_get_ctldata(spi)) {
+ 		err = gpio_request_one(cs->line, GPIOF_OUT_INIT_HIGH,
+ 				       dev_name(&spi->dev));
+ 		if (err) {
+ 			dev_err(&spi->dev,
+ 				"Failed to get /CS gpio [%d]: %d\n",
+ 				cs->line, err);
+ 			goto err_gpio_req;
+ 		}
+ 		spi_set_ctldata(spi, cs);
+ 	}
+ 
  	sci = sdd->cntrlr_info;
  
  	spin_lock_irqsave(&sdd->lock, flags);
***************
*** 826,832 ****
  			dev_err(&spi->dev,
  				"setup: attempt while mssg in queue!\n");
  			spin_unlock_irqrestore(&sdd->lock, flags);
- 			return -EBUSY;
  		}
  	}
  
--- 911,918 ----
  			dev_err(&spi->dev,
  				"setup: attempt while mssg in queue!\n");
  			spin_unlock_irqrestore(&sdd->lock, flags);
+ 			err = -EBUSY;
+ 			goto err_msgq;
  		}
  	}
  
***************
*** 844,850 ****
  	pm_runtime_get_sync(&sdd->pdev->dev);
  
  	/* Check if we can provide the requested rate */
- 	if (!sci->clk_from_cmu) {
  		u32 psr, speed;
  
  		/* Max possible */
--- 930,936 ----
  	pm_runtime_get_sync(&sdd->pdev->dev);
  
  	/* Check if we can provide the requested rate */
+ 	if (!sdd->port_conf->clk_from_cmu) {
  		u32 psr, speed;
  
  		/* Max possible */
***************
*** 869,890 ****
  		}
  
  		speed = clk_get_rate(sdd->src_clk) / 2 / (psr + 1);
- 		if (spi->max_speed_hz >= speed)
  			spi->max_speed_hz = speed;
- 		else
  			err = -EINVAL;
  	}
  
  	pm_runtime_put(&sdd->pdev->dev);
  
  setup_exit:
- 
  	/* setup() returns with device de-selected */
  	disable_cs(sdd, spi);
  
  	return err;
  }
  
  static irqreturn_t s3c64xx_spi_irq(int irq, void *data)
  {
  	struct s3c64xx_spi_driver_data *sdd = data;
--- 955,998 ----
  		}
  
  		speed = clk_get_rate(sdd->src_clk) / 2 / (psr + 1);
+ 		if (spi->max_speed_hz >= speed) {
  			spi->max_speed_hz = speed;
+ 		} else {
  			err = -EINVAL;
+ 			goto setup_exit;
+ 		}
  	}
  
  	pm_runtime_put(&sdd->pdev->dev);
+ 	disable_cs(sdd, spi);
+ 	return 0;
  
  setup_exit:
  	/* setup() returns with device de-selected */
  	disable_cs(sdd, spi);
  
+ err_msgq:
+ 	gpio_free(cs->line);
+ 	spi_set_ctldata(spi, NULL);
+ 
+ err_gpio_req:
+ 	kfree(cs);
+ 
  	return err;
  }
  
+ static void s3c64xx_spi_cleanup(struct spi_device *spi)
+ {
+ 	struct s3c64xx_spi_csinfo *cs = spi_get_ctldata(spi);
+ 
+ 	if (cs) {
+ 		gpio_free(cs->line);
+ 		if (spi->dev.of_node)
+ 			kfree(cs);
+ 	}
+ 	spi_set_ctldata(spi, NULL);
+ }
+ 
  static irqreturn_t s3c64xx_spi_irq(int irq, void *data)
  {
  	struct s3c64xx_spi_driver_data *sdd = data;
***************
*** 920,931 ****
  
  	sdd->cur_speed = 0;
  
- 	S3C64XX_SPI_DEACT(sdd);
  
  	/* Disable Interrupts - we use Polling if not DMA mode */
  	writel(0, regs + S3C64XX_SPI_INT_EN);
  
- 	if (!sci->clk_from_cmu)
  		writel(sci->src_clk_nr << S3C64XX_SPI_CLKSEL_SRCSHFT,
  				regs + S3C64XX_SPI_CLK_CFG);
  	writel(0, regs + S3C64XX_SPI_MODE_CFG);
--- 1028,1039 ----
  
  	sdd->cur_speed = 0;
  
+ 	writel(S3C64XX_SPI_SLAVE_SIG_INACT, sdd->regs + S3C64XX_SPI_SLAVE_SEL);
  
  	/* Disable Interrupts - we use Polling if not DMA mode */
  	writel(0, regs + S3C64XX_SPI_INT_EN);
  
+ 	if (!sdd->port_conf->clk_from_cmu)
  		writel(sci->src_clk_nr << S3C64XX_SPI_CLKSEL_SRCSHFT,
  				regs + S3C64XX_SPI_CLK_CFG);
  	writel(0, regs + S3C64XX_SPI_MODE_CFG);
***************
*** 946,985 ****
  	flush_fifo(sdd);
  }
  
- static int __init s3c64xx_spi_probe(struct platform_device *pdev)
  {
- 	struct resource	*mem_res, *dmatx_res, *dmarx_res;
- 	struct s3c64xx_spi_driver_data *sdd;
  	struct s3c64xx_spi_info *sci;
- 	struct spi_master *master;
- 	int ret, irq;
- 	char clk_name[16];
  
- 	if (pdev->id < 0) {
- 		dev_err(&pdev->dev,
- 				"Invalid platform device id-%d\n", pdev->id);
- 		return -ENODEV;
  	}
  
- 	if (pdev->dev.platform_data == NULL) {
- 		dev_err(&pdev->dev, "platform_data missing!\n");
- 		return -ENODEV;
  	}
  
- 	sci = pdev->dev.platform_data;
  
- 	/* Check for availability of necessary resource */
  
- 	dmatx_res = platform_get_resource(pdev, IORESOURCE_DMA, 0);
- 	if (dmatx_res == NULL) {
- 		dev_err(&pdev->dev, "Unable to get SPI-Tx dma resource\n");
- 		return -ENXIO;
  	}
  
- 	dmarx_res = platform_get_resource(pdev, IORESOURCE_DMA, 1);
- 	if (dmarx_res == NULL) {
- 		dev_err(&pdev->dev, "Unable to get SPI-Rx dma resource\n");
- 		return -ENXIO;
  	}
  
  	mem_res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
--- 1054,1218 ----
  	flush_fifo(sdd);
  }
  
+ static int __devinit s3c64xx_spi_get_dmares(
+ 			struct s3c64xx_spi_driver_data *sdd, bool tx)
+ {
+ 	struct platform_device *pdev = sdd->pdev;
+ 	struct s3c64xx_spi_dma_data *dma_data;
+ 	struct property *prop;
+ 	struct resource *res;
+ 	char prop_name[15], *chan_str;
+ 
+ 	if (tx) {
+ 		dma_data = &sdd->tx_dma;
+ 		dma_data->direction = DMA_TO_DEVICE;
+ 		chan_str = "tx";
+ 	} else {
+ 		dma_data = &sdd->rx_dma;
+ 		dma_data->direction = DMA_FROM_DEVICE;
+ 		chan_str = "rx";
+ 	}
+ 
+ 	if (!sdd->pdev->dev.of_node) {
+ 		res = platform_get_resource(pdev, IORESOURCE_DMA, tx ? 0 : 1);
+ 		if (!res) {
+ 			dev_err(&pdev->dev, "Unable to get SPI-%s dma "
+ 					"resource\n", chan_str);
+ 			return -ENXIO;
+ 		}
+ 		dma_data->dmach = res->start;
+ 		return 0;
+ 	}
+ 
+ 	sprintf(prop_name, "%s-dma-channel", chan_str);
+ 	prop = of_find_property(pdev->dev.of_node, prop_name, NULL);
+ 	if (!prop) {
+ 		dev_err(&pdev->dev, "%s dma channel property not specified\n",
+ 					chan_str);
+ 		return -ENXIO;
+ 	}
+ 
+ 	dma_data->dmach = DMACH_DT_PROP;
+ 	dma_data->dma_prop = prop;
+ 	return 0;
+ }
+ 
+ #ifdef CONFIG_OF
+ static int s3c64xx_spi_parse_dt_gpio(struct s3c64xx_spi_driver_data *sdd)
+ {
+ 	struct device *dev = &sdd->pdev->dev;
+ 	int idx, gpio, ret;
+ 
+ 	/* find gpios for mosi, miso and clock lines */
+ 	for (idx = 0; idx < 3; idx++) {
+ 		gpio = of_get_gpio(dev->of_node, idx);
+ 		if (!gpio_is_valid(gpio)) {
+ 			dev_err(dev, "invalid gpio[%d]: %d\n", idx, gpio);
+ 			goto free_gpio;
+ 		}
+ 
+ 		ret = gpio_request(gpio, "spi-bus");
+ 		if (ret) {
+ 			dev_err(dev, "gpio [%d] request failed: %d\n",
+ 				gpio, ret);
+ 			goto free_gpio;
+ 		}
+ 	}
+ 	return 0;
+ 
+ free_gpio:
+ 	while (--idx >= 0)
+ 		gpio_free(sdd->gpios[idx]);
+ 	return -EINVAL;
+ }
+ 
+ static void s3c64xx_spi_dt_gpio_free(struct s3c64xx_spi_driver_data *sdd)
+ {
+ 	unsigned int idx;
+ 	for (idx = 0; idx < 3; idx++)
+ 		gpio_free(sdd->gpios[idx]);
+ }
+ 
+ static struct __devinit s3c64xx_spi_info * s3c64xx_spi_parse_dt(
+ 						struct device *dev)
  {
  	struct s3c64xx_spi_info *sci;
+ 	u32 temp;
  
+ 	sci = devm_kzalloc(dev, sizeof(*sci), GFP_KERNEL);
+ 	if (!sci) {
+ 		dev_err(dev, "memory allocation for spi_info failed\n");
+ 		return ERR_PTR(-ENOMEM);
  	}
  
+ 	if (of_property_read_u32(dev->of_node, "samsung,spi-src-clk", &temp)) {
+ 		dev_warn(dev, "spi bus clock parent not specified, using "
+ 				"clock at index 0 as parent\n");
+ 		sci->src_clk_nr = 0;
+ 	} else {
+ 		sci->src_clk_nr = temp;
  	}
  
+ 	if (of_property_read_u32(dev->of_node, "num-cs", &temp)) {
+ 		dev_warn(dev, "number of chip select lines not specified, "
+ 				"assuming 1 chip select line\n");
+ 		sci->num_cs = 1;
+ 	} else {
+ 		sci->num_cs = temp;
+ 	}
+ 
+ 	return sci;
+ }
+ #else
+ static struct s3c64xx_spi_info *s3c64xx_spi_parse_dt(struct device *dev)
+ {
+ 	return dev->platform_data;
+ }
+ 
+ static int s3c64xx_spi_parse_dt_gpio(struct s3c64xx_spi_driver_data *sdd)
+ {
+ 	return -EINVAL;
+ }
+ 
+ static void s3c64xx_spi_dt_gpio_free(struct s3c64xx_spi_driver_data *sdd)
+ {
+ }
+ #endif
  
+ static const struct of_device_id s3c64xx_spi_dt_match[];
  
+ static inline struct s3c64xx_spi_port_config *s3c64xx_spi_get_port_config(
+ 						struct platform_device *pdev)
+ {
+ #ifdef CONFIG_OF
+ 	if (pdev->dev.of_node) {
+ 		const struct of_device_id *match;
+ 		match = of_match_node(s3c64xx_spi_dt_match, pdev->dev.of_node);
+ 		return (struct s3c64xx_spi_port_config *)match->data;
  	}
+ #endif
+ 	return (struct s3c64xx_spi_port_config *)
+ 			 platform_get_device_id(pdev)->driver_data;
+ }
  
+ static int __init s3c64xx_spi_probe(struct platform_device *pdev)
+ {
+ 	struct resource	*mem_res;
+ 	struct s3c64xx_spi_driver_data *sdd;
+ 	struct s3c64xx_spi_info *sci = pdev->dev.platform_data;
+ 	struct spi_master *master;
+ 	int ret, irq;
+ 	char clk_name[16];
+ 
+ 	if (!sci && pdev->dev.of_node) {
+ 		sci = s3c64xx_spi_parse_dt(&pdev->dev);
+ 		if (IS_ERR(sci))
+ 			return PTR_ERR(sci);
+ 	}
+ 
+ 	if (!sci) {
+ 		dev_err(&pdev->dev, "platform_data missing!\n");
+ 		return -ENODEV;
  	}
  
  	mem_res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
***************
*** 1004,1022 ****
  	platform_set_drvdata(pdev, master);
  
  	sdd = spi_master_get_devdata(master);
  	sdd->master = master;
  	sdd->cntrlr_info = sci;
  	sdd->pdev = pdev;
  	sdd->sfr_start = mem_res->start;
- 	sdd->tx_dma.dmach = dmatx_res->start;
- 	sdd->tx_dma.direction = DMA_MEM_TO_DEV;
- 	sdd->rx_dma.dmach = dmarx_res->start;
- 	sdd->rx_dma.direction = DMA_DEV_TO_MEM;
  
  	sdd->cur_bpw = 8;
  
- 	master->bus_num = pdev->id;
  	master->setup = s3c64xx_spi_setup;
  	master->prepare_transfer_hardware = s3c64xx_spi_prepare_transfer;
  	master->transfer_one_message = s3c64xx_spi_transfer_one_message;
  	master->unprepare_transfer_hardware = s3c64xx_spi_unprepare_transfer;
--- 1237,1273 ----
  	platform_set_drvdata(pdev, master);
  
  	sdd = spi_master_get_devdata(master);
+ 	sdd->port_conf = s3c64xx_spi_get_port_config(pdev);
  	sdd->master = master;
  	sdd->cntrlr_info = sci;
  	sdd->pdev = pdev;
  	sdd->sfr_start = mem_res->start;
+ 	if (pdev->dev.of_node) {
+ 		ret = of_alias_get_id(pdev->dev.of_node, "spi");
+ 		if (ret < 0) {
+ 			dev_err(&pdev->dev, "failed to get alias id, "
+ 						"errno %d\n", ret);
+ 			goto err0;
+ 		}
+ 		sdd->port_id = ret;
+ 	} else {
+ 		sdd->port_id = pdev->id;
+ 	}
  
  	sdd->cur_bpw = 8;
  
+ 	ret = s3c64xx_spi_get_dmares(sdd, true);
+ 	if (ret)
+ 		goto err0;
+ 
+ 	ret = s3c64xx_spi_get_dmares(sdd, false);
+ 	if (ret)
+ 		goto err0;
+ 
+ 	master->dev.of_node = pdev->dev.of_node;
+ 	master->bus_num = sdd->port_id;
  	master->setup = s3c64xx_spi_setup;
+ 	master->cleanup = s3c64xx_spi_cleanup;
  	master->prepare_transfer_hardware = s3c64xx_spi_prepare_transfer;
  	master->transfer_one_message = s3c64xx_spi_transfer_one_message;
  	master->unprepare_transfer_hardware = s3c64xx_spi_unprepare_transfer;
***************
*** 1025,1045 ****
  	/* the spi->mode bits understood by this driver: */
  	master->mode_bits = SPI_CPOL | SPI_CPHA | SPI_CS_HIGH;
  
- 	if (request_mem_region(mem_res->start,
- 			resource_size(mem_res), pdev->name) == NULL) {
- 		dev_err(&pdev->dev, "Req mem region failed\n");
- 		ret = -ENXIO;
- 		goto err0;
- 	}
- 
- 	sdd->regs = ioremap(mem_res->start, resource_size(mem_res));
  	if (sdd->regs == NULL) {
  		dev_err(&pdev->dev, "Unable to remap IO\n");
  		ret = -ENXIO;
  		goto err1;
  	}
  
- 	if (sci->cfg_gpio == NULL || sci->cfg_gpio(pdev)) {
  		dev_err(&pdev->dev, "Unable to config gpio\n");
  		ret = -EBUSY;
  		goto err2;
--- 1276,1292 ----
  	/* the spi->mode bits understood by this driver: */
  	master->mode_bits = SPI_CPOL | SPI_CPHA | SPI_CS_HIGH;
  
+ 	sdd->regs = devm_request_and_ioremap(&pdev->dev, mem_res);
  	if (sdd->regs == NULL) {
  		dev_err(&pdev->dev, "Unable to remap IO\n");
  		ret = -ENXIO;
  		goto err1;
  	}
  
+ 	if (!sci->cfg_gpio && pdev->dev.of_node) {
+ 		if (s3c64xx_spi_parse_dt_gpio(sdd))
+ 			return -EBUSY;
+ 	} else if (sci->cfg_gpio == NULL || sci->cfg_gpio()) {
  		dev_err(&pdev->dev, "Unable to config gpio\n");
  		ret = -EBUSY;
  		goto err2;
***************
*** 1075,1081 ****
  	}
  
  	/* Setup Deufult Mode */
- 	s3c64xx_spi_hwinit(sdd, pdev->id);
  
  	spin_lock_init(&sdd->lock);
  	init_completion(&sdd->xfer_completion);
--- 1322,1328 ----
  	}
  
  	/* Setup Deufult Mode */
+ 	s3c64xx_spi_hwinit(sdd, sdd->port_id);
  
  	spin_lock_init(&sdd->lock);
  	init_completion(&sdd->xfer_completion);
***************
*** 1100,1106 ****
  
  	dev_dbg(&pdev->dev, "Samsung SoC SPI Driver loaded for Bus SPI-%d "
  					"with %d Slaves attached\n",
- 					pdev->id, master->num_chipselect);
  	dev_dbg(&pdev->dev, "\tIOmem=[0x%x-0x%x]\tDMA=[Rx-%d, Tx-%d]\n",
  					mem_res->end, mem_res->start,
  					sdd->rx_dma.dmach, sdd->tx_dma.dmach);
--- 1347,1353 ----
  
  	dev_dbg(&pdev->dev, "Samsung SoC SPI Driver loaded for Bus SPI-%d "
  					"with %d Slaves attached\n",
+ 					sdd->port_id, master->num_chipselect);
  	dev_dbg(&pdev->dev, "\tIOmem=[0x%x-0x%x]\tDMA=[Rx-%d, Tx-%d]\n",
  					mem_res->end, mem_res->start,
  					sdd->rx_dma.dmach, sdd->tx_dma.dmach);
***************
*** 1120,1129 ****
  err4:
  	clk_put(sdd->clk);
  err3:
  err2:
- 	iounmap((void *) sdd->regs);
  err1:
- 	release_mem_region(mem_res->start, resource_size(mem_res));
  err0:
  	platform_set_drvdata(pdev, NULL);
  	spi_master_put(master);
--- 1367,1376 ----
  err4:
  	clk_put(sdd->clk);
  err3:
+ 	if (!sdd->cntrlr_info->cfg_gpio && pdev->dev.of_node)
+ 		s3c64xx_spi_dt_gpio_free(sdd);
  err2:
  err1:
  err0:
  	platform_set_drvdata(pdev, NULL);
  	spi_master_put(master);
***************
*** 1135,1141 ****
  {
  	struct spi_master *master = spi_master_get(platform_get_drvdata(pdev));
  	struct s3c64xx_spi_driver_data *sdd = spi_master_get_devdata(master);
- 	struct resource	*mem_res;
  
  	pm_runtime_disable(&pdev->dev);
  
--- 1382,1387 ----
  {
  	struct spi_master *master = spi_master_get(platform_get_drvdata(pdev));
  	struct s3c64xx_spi_driver_data *sdd = spi_master_get_devdata(master);
  
  	pm_runtime_disable(&pdev->dev);
  
***************
*** 1151,1161 ****
  	clk_disable(sdd->clk);
  	clk_put(sdd->clk);
  
- 	iounmap((void *) sdd->regs);
- 
- 	mem_res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
- 	if (mem_res != NULL)
- 		release_mem_region(mem_res->start, resource_size(mem_res));
  
  	platform_set_drvdata(pdev, NULL);
  	spi_master_put(master);
--- 1397,1404 ----
  	clk_disable(sdd->clk);
  	clk_put(sdd->clk);
  
+ 	if (!sdd->cntrlr_info->cfg_gpio && pdev->dev.of_node)
+ 		s3c64xx_spi_dt_gpio_free(sdd);
  
  	platform_set_drvdata(pdev, NULL);
  	spi_master_put(master);
***************
*** 1175,1180 ****
  	clk_disable(sdd->src_clk);
  	clk_disable(sdd->clk);
  
  	sdd->cur_speed = 0; /* Output Clock is stopped */
  
  	return 0;
--- 1418,1426 ----
  	clk_disable(sdd->src_clk);
  	clk_disable(sdd->clk);
  
+ 	if (!sdd->cntrlr_info->cfg_gpio && dev->of_node)
+ 		s3c64xx_spi_dt_gpio_free(sdd);
+ 
  	sdd->cur_speed = 0; /* Output Clock is stopped */
  
  	return 0;
***************
*** 1182,1199 ****
  
  static int s3c64xx_spi_resume(struct device *dev)
  {
- 	struct platform_device *pdev = to_platform_device(dev);
  	struct spi_master *master = spi_master_get(dev_get_drvdata(dev));
  	struct s3c64xx_spi_driver_data *sdd = spi_master_get_devdata(master);
  	struct s3c64xx_spi_info *sci = sdd->cntrlr_info;
  
- 	sci->cfg_gpio(pdev);
  
  	/* Enable the clock */
  	clk_enable(sdd->src_clk);
  	clk_enable(sdd->clk);
  
- 	s3c64xx_spi_hwinit(sdd, pdev->id);
  
  	spi_master_resume(master);
  
--- 1428,1447 ----
  
  static int s3c64xx_spi_resume(struct device *dev)
  {
  	struct spi_master *master = spi_master_get(dev_get_drvdata(dev));
  	struct s3c64xx_spi_driver_data *sdd = spi_master_get_devdata(master);
  	struct s3c64xx_spi_info *sci = sdd->cntrlr_info;
  
+ 	if (!sci->cfg_gpio && dev->of_node)
+ 		s3c64xx_spi_parse_dt_gpio(sdd);
+ 	else
+ 		sci->cfg_gpio();
  
  	/* Enable the clock */
  	clk_enable(sdd->src_clk);
  	clk_enable(sdd->clk);
  
+ 	s3c64xx_spi_hwinit(sdd, sdd->port_id);
  
  	spi_master_resume(master);
  
***************
*** 1231,1243 ****
  			   s3c64xx_spi_runtime_resume, NULL)
  };
  
  static struct platform_driver s3c64xx_spi_driver = {
  	.driver = {
  		.name	= "s3c64xx-spi",
  		.owner = THIS_MODULE,
  		.pm = &s3c64xx_spi_pm,
  	},
  	.remove = s3c64xx_spi_remove,
  };
  MODULE_ALIAS("platform:s3c64xx-spi");
  
--- 1479,1567 ----
  			   s3c64xx_spi_runtime_resume, NULL)
  };
  
+ static struct s3c64xx_spi_port_config s3c2443_spi_port_config = {
+ 	.fifo_lvl_mask	= { 0x7f },
+ 	.rx_lvl_offset	= 13,
+ 	.tx_st_done	= 21,
+ 	.high_speed	= true,
+ };
+ 
+ static struct s3c64xx_spi_port_config s3c6410_spi_port_config = {
+ 	.fifo_lvl_mask	= { 0x7f, 0x7F },
+ 	.rx_lvl_offset	= 13,
+ 	.tx_st_done	= 21,
+ };
+ 
+ static struct s3c64xx_spi_port_config s5p64x0_spi_port_config = {
+ 	.fifo_lvl_mask	= { 0x1ff, 0x7F },
+ 	.rx_lvl_offset	= 15,
+ 	.tx_st_done	= 25,
+ };
+ 
+ static struct s3c64xx_spi_port_config s5pc100_spi_port_config = {
+ 	.fifo_lvl_mask	= { 0x7f, 0x7F },
+ 	.rx_lvl_offset	= 13,
+ 	.tx_st_done	= 21,
+ 	.high_speed	= true,
+ };
+ 
+ static struct s3c64xx_spi_port_config s5pv210_spi_port_config = {
+ 	.fifo_lvl_mask	= { 0x1ff, 0x7F },
+ 	.rx_lvl_offset	= 15,
+ 	.tx_st_done	= 25,
+ 	.high_speed	= true,
+ };
+ 
+ static struct s3c64xx_spi_port_config exynos4_spi_port_config = {
+ 	.fifo_lvl_mask	= { 0x1ff, 0x7F, 0x7F },
+ 	.rx_lvl_offset	= 15,
+ 	.tx_st_done	= 25,
+ 	.high_speed	= true,
+ 	.clk_from_cmu	= true,
+ };
+ 
+ static struct platform_device_id s3c64xx_spi_driver_ids[] = {
+ 	{
+ 		.name		= "s3c2443-spi",
+ 		.driver_data	= (kernel_ulong_t)&s3c2443_spi_port_config,
+ 	}, {
+ 		.name		= "s3c6410-spi",
+ 		.driver_data	= (kernel_ulong_t)&s3c6410_spi_port_config,
+ 	}, {
+ 		.name		= "s5p64x0-spi",
+ 		.driver_data	= (kernel_ulong_t)&s5p64x0_spi_port_config,
+ 	}, {
+ 		.name		= "s5pc100-spi",
+ 		.driver_data	= (kernel_ulong_t)&s5pc100_spi_port_config,
+ 	}, {
+ 		.name		= "s5pv210-spi",
+ 		.driver_data	= (kernel_ulong_t)&s5pv210_spi_port_config,
+ 	}, {
+ 		.name		= "exynos4210-spi",
+ 		.driver_data	= (kernel_ulong_t)&exynos4_spi_port_config,
+ 	},
+ 	{ },
+ };
+ 
+ #ifdef CONFIG_OF
+ static const struct of_device_id s3c64xx_spi_dt_match[] = {
+ 	{ .compatible = "samsung,exynos4210-spi",
+ 			.data = (void *)&exynos4_spi_port_config,
+ 	},
+ 	{ },
+ };
+ MODULE_DEVICE_TABLE(of, s3c64xx_spi_dt_match);
+ #endif /* CONFIG_OF */
+ 
  static struct platform_driver s3c64xx_spi_driver = {
  	.driver = {
  		.name	= "s3c64xx-spi",
  		.owner = THIS_MODULE,
  		.pm = &s3c64xx_spi_pm,
+ 		.of_match_table = of_match_ptr(s3c64xx_spi_dt_match),
  	},
  	.remove = s3c64xx_spi_remove,
+ 	.id_table = s3c64xx_spi_driver_ids,
  };
  MODULE_ALIAS("platform:s3c64xx-spi");
  
