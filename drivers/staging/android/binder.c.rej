***************
*** 2523,2536 ****
  			struct binder_transaction *t;
  
  			t = container_of(w, struct binder_transaction, work);
- 			if (t->buffer->target_node && !(t->flags & TF_ONE_WAY))
  				binder_send_failed_reply(t, BR_DEAD_REPLY);
  		} break;
  		case BINDER_WORK_TRANSACTION_COMPLETE: {
  			kfree(w);
  			binder_stats_deleted(BINDER_STAT_TRANSACTION_COMPLETE);
  		} break;
  		default:
  			break;
  		}
  	}
--- 2523,2560 ----
  			struct binder_transaction *t;
  
  			t = container_of(w, struct binder_transaction, work);
+ 			if (t->buffer->target_node &&
+ 			    !(t->flags & TF_ONE_WAY)) {
  				binder_send_failed_reply(t, BR_DEAD_REPLY);
+ 			} else {
+ 				binder_debug(BINDER_DEBUG_DEAD_TRANSACTION,
+ 					"binder: undelivered transaction %d\n",
+ 					t->debug_id);
+ 				t->buffer->transaction = NULL;
+ 				kfree(t);
+ 				binder_stats_deleted(BINDER_STAT_TRANSACTION);
+ 			}
  		} break;
  		case BINDER_WORK_TRANSACTION_COMPLETE: {
+ 			binder_debug(BINDER_DEBUG_DEAD_TRANSACTION,
+ 				"binder: undelivered TRANSACTION_COMPLETE\n");
  			kfree(w);
  			binder_stats_deleted(BINDER_STAT_TRANSACTION_COMPLETE);
  		} break;
+ 		case BINDER_WORK_DEAD_BINDER_AND_CLEAR:
+ 		case BINDER_WORK_CLEAR_DEATH_NOTIFICATION: {
+ 			struct binder_ref_death *death;
+ 
+ 			death = container_of(w, struct binder_ref_death, work);
+ 			binder_debug(BINDER_DEBUG_DEAD_TRANSACTION,
+ 				"binder: undelivered death notification, %p\n",
+ 				death->cookie);
+ 			kfree(death);
+ 			binder_stats_deleted(BINDER_STAT_DEATH);
+ 		} break;
  		default:
+ 			pr_err("binder: unexpected work type, %d, not freed\n",
+ 			       w->type);
  			break;
  		}
  	}
***************
*** 3000,3005 ****
  		nodes++;
  		rb_erase(&node->rb_node, &proc->nodes);
  		list_del_init(&node->work.entry);
  		if (hlist_empty(&node->refs)) {
  			kfree(node);
  			binder_stats_deleted(BINDER_STAT_NODE);
--- 3024,3030 ----
  		nodes++;
  		rb_erase(&node->rb_node, &proc->nodes);
  		list_del_init(&node->work.entry);
+ 		binder_release_work(&node->async_todo);
  		if (hlist_empty(&node->refs)) {
  			kfree(node);
  			binder_stats_deleted(BINDER_STAT_NODE);
***************
*** 3038,3043 ****
  		binder_delete_ref(ref);
  	}
  	binder_release_work(&proc->todo);
  	buffers = 0;
  
  	while ((n = rb_first(&proc->allocated_buffers))) {
--- 3063,3069 ----
  		binder_delete_ref(ref);
  	}
  	binder_release_work(&proc->todo);
+ 	binder_release_work(&proc->delivered_death);
  	buffers = 0;
  
  	while ((n = rb_first(&proc->allocated_buffers))) {
