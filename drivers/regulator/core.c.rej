***************
*** 108,135 ****
  		return "";
  }
  
- /* gets the regulator for a given consumer device */
- static struct regulator *get_device_regulator(struct device *dev)
- {
- 	struct regulator *regulator = NULL;
- 	struct regulator_dev *rdev;
- 
- 	mutex_lock(&regulator_list_mutex);
- 	list_for_each_entry(rdev, &regulator_list, list) {
- 		mutex_lock(&rdev->mutex);
- 		list_for_each_entry(regulator, &rdev->consumer_list, list) {
- 			if (regulator->dev == dev) {
- 				mutex_unlock(&rdev->mutex);
- 				mutex_unlock(&regulator_list_mutex);
- 				return regulator;
- 			}
- 		}
- 		mutex_unlock(&rdev->mutex);
- 	}
- 	mutex_unlock(&regulator_list_mutex);
- 	return NULL;
- }
- 
  /**
   * of_get_regulator - get a regulator device node based on supply name
   * @dev: Device pointer for the consumer (of regulator) device
--- 109,114 ----
  		return "";
  }
  
  /**
   * of_get_regulator - get a regulator device node based on supply name
   * @dev: Device pointer for the consumer (of regulator) device
***************
*** 303,320 ****
  	return 0;
  }
  
- static ssize_t device_requested_uA_show(struct device *dev,
- 			     struct device_attribute *attr, char *buf)
- {
- 	struct regulator *regulator;
- 
- 	regulator = get_device_regulator(dev);
- 	if (regulator == NULL)
- 		return 0;
- 
- 	return sprintf(buf, "%d\n", regulator->uA_load);
- }
- 
  static ssize_t regulator_uV_show(struct device *dev,
  				struct device_attribute *attr, char *buf)
  {
--- 282,287 ----
  	return 0;
  }
  
  static ssize_t regulator_uV_show(struct device *dev,
  				struct device_attribute *attr, char *buf)
  {
***************
*** 1071,1118 ****
  	list_add(&regulator->list, &rdev->consumer_list);
  
  	if (dev) {
- 		/* create a 'requested_microamps_name' sysfs entry */
- 		size = scnprintf(buf, REG_STR_SIZE,
- 				 "microamps_requested_%s-%s",
- 				 dev_name(dev), supply_name);
- 		if (size >= REG_STR_SIZE)
- 			goto overflow_err;
- 
  		regulator->dev = dev;
- 		sysfs_attr_init(&regulator->dev_attr.attr);
- 		regulator->dev_attr.attr.name = kstrdup(buf, GFP_KERNEL);
- 		if (regulator->dev_attr.attr.name == NULL)
- 			goto attr_name_err;
- 
- 		regulator->dev_attr.attr.mode = 0444;
- 		regulator->dev_attr.show = device_requested_uA_show;
- 		err = device_create_file(dev, &regulator->dev_attr);
- 		if (err < 0) {
- 			rdev_warn(rdev, "could not add regulator_dev requested microamps sysfs entry\n");
- 			goto attr_name_err;
- 		}
  
- 		/* also add a link to the device sysfs entry */
  		size = scnprintf(buf, REG_STR_SIZE, "%s-%s",
  				 dev->kobj.name, supply_name);
  		if (size >= REG_STR_SIZE)
- 			goto attr_err;
  
  		regulator->supply_name = kstrdup(buf, GFP_KERNEL);
  		if (regulator->supply_name == NULL)
- 			goto attr_err;
  
  		err = sysfs_create_link(&rdev->dev.kobj, &dev->kobj,
  					buf);
  		if (err) {
  			rdev_warn(rdev, "could not add device link %s err %d\n",
  				  dev->kobj.name, err);
- 			goto link_name_err;
  		}
  	} else {
  		regulator->supply_name = kstrdup(supply_name, GFP_KERNEL);
  		if (regulator->supply_name == NULL)
- 			goto attr_err;
  	}
  
  	regulator->debugfs = debugfs_create_dir(regulator->supply_name,
--- 1049,1077 ----
  	list_add(&regulator->list, &rdev->consumer_list);
  
  	if (dev) {
  		regulator->dev = dev;
  
+ 		/* Add a link to the device sysfs entry */
  		size = scnprintf(buf, REG_STR_SIZE, "%s-%s",
  				 dev->kobj.name, supply_name);
  		if (size >= REG_STR_SIZE)
+ 			goto overflow_err;
  
  		regulator->supply_name = kstrdup(buf, GFP_KERNEL);
  		if (regulator->supply_name == NULL)
+ 			goto overflow_err;
  
  		err = sysfs_create_link(&rdev->dev.kobj, &dev->kobj,
  					buf);
  		if (err) {
  			rdev_warn(rdev, "could not add device link %s err %d\n",
  				  dev->kobj.name, err);
+ 			/* non-fatal */
  		}
  	} else {
  		regulator->supply_name = kstrdup(supply_name, GFP_KERNEL);
  		if (regulator->supply_name == NULL)
+ 			goto overflow_err;
  	}
  
  	regulator->debugfs = debugfs_create_dir(regulator->supply_name,
***************
*** 1139,1150 ****
  
  	mutex_unlock(&rdev->mutex);
  	return regulator;
- link_name_err:
- 	kfree(regulator->supply_name);
- attr_err:
- 	device_remove_file(regulator->dev, &regulator->dev_attr);
- attr_name_err:
- 	kfree(regulator->dev_attr.attr.name);
  overflow_err:
  	list_del(&regulator->list);
  	kfree(regulator);
--- 1098,1103 ----
  
  	mutex_unlock(&rdev->mutex);
  	return regulator;
  overflow_err:
  	list_del(&regulator->list);
  	kfree(regulator);
***************
*** 1406,1424 ****
  {
  	int rc;
  
- 	rc = devres_destroy(regulator->dev, devm_regulator_release,
  			    devm_regulator_match, regulator);
- 	if (rc == 0)
- 		regulator_put(regulator);
- 	else
  		WARN_ON(rc);
  }
  EXPORT_SYMBOL_GPL(devm_regulator_put);
  
  /* locks held by regulator_enable() */
  static int _regulator_enable(struct regulator_dev *rdev)
  {
- 	int ret, delay;
  
  	/* check voltage and requested load before enabling */
  	if (rdev->constraints &&
--- 1356,1416 ----
  {
  	int rc;
  
+ 	rc = devres_release(regulator->dev, devm_regulator_release,
  			    devm_regulator_match, regulator);
+ 	if (rc != 0)
  		WARN_ON(rc);
  }
  EXPORT_SYMBOL_GPL(devm_regulator_put);
  
+ static int _regulator_do_enable(struct regulator_dev *rdev)
+ {
+ 	int ret, delay;
+ 
+ 	/* Query before enabling in case configuration dependent.  */
+ 	ret = _regulator_get_enable_time(rdev);
+ 	if (ret >= 0) {
+ 		delay = ret;
+ 	} else {
+ 		rdev_warn(rdev, "enable_time() failed: %d\n", ret);
+ 		delay = 0;
+ 	}
+ 
+ 	trace_regulator_enable(rdev_get_name(rdev));
+ 
+ 	if (rdev->ena_gpio) {
+ 		gpio_set_value_cansleep(rdev->ena_gpio,
+ 					!rdev->ena_gpio_invert);
+ 		rdev->ena_gpio_state = 1;
+ 	} else if (rdev->desc->ops->enable) {
+ 		ret = rdev->desc->ops->enable(rdev);
+ 		if (ret < 0)
+ 			return ret;
+ 	} else {
+ 		return -EINVAL;
+ 	}
+ 
+ 	/* Allow the regulator to ramp; it would be useful to extend
+ 	 * this for bulk operations so that the regulators can ramp
+ 	 * together.  */
+ 	trace_regulator_enable_delay(rdev_get_name(rdev));
+ 
+ 	if (delay >= 1000) {
+ 		mdelay(delay / 1000);
+ 		udelay(delay % 1000);
+ 	} else if (delay) {
+ 		udelay(delay);
+ 	}
+ 
+ 	trace_regulator_enable_complete(rdev_get_name(rdev));
+ 
+ 	return 0;
+ }
+ 
  /* locks held by regulator_enable() */
  static int _regulator_enable(struct regulator_dev *rdev)
  {
+ 	int ret;
  
  	/* check voltage and requested load before enabling */
  	if (rdev->constraints &&
***************
*** 2062,2068 ****
  	 * If we can't obtain the old selector there is not enough
  	 * info to call set_voltage_time_sel().
  	 */
- 	if (rdev->desc->ops->set_voltage_time_sel &&
  	    rdev->desc->ops->get_voltage_sel) {
  		old_selector = rdev->desc->ops->get_voltage_sel(rdev);
  		if (old_selector < 0)
--- 2087,2094 ----
  	 * If we can't obtain the old selector there is not enough
  	 * info to call set_voltage_time_sel().
  	 */
+ 	if (_regulator_is_enabled(rdev) &&
+ 	    rdev->desc->ops->set_voltage_time_sel &&
  	    rdev->desc->ops->get_voltage_sel) {
  		old_selector = rdev->desc->ops->get_voltage_sel(rdev);
  		if (old_selector < 0)
***************
*** 2072,2100 ****
  	if (rdev->desc->ops->set_voltage) {
  		ret = rdev->desc->ops->set_voltage(rdev, min_uV, max_uV,
  						   &selector);
  	} else if (rdev->desc->ops->set_voltage_sel) {
- 		if (rdev->desc->ops->map_voltage)
  			ret = rdev->desc->ops->map_voltage(rdev, min_uV,
  							   max_uV);
- 		else
- 			ret = regulator_map_voltage_iterate(rdev, min_uV,
- 							    max_uV);
  
  		if (ret >= 0) {
- 			selector = ret;
- 			ret = rdev->desc->ops->set_voltage_sel(rdev, ret);
  		}
  	} else {
  		ret = -EINVAL;
  	}
  
- 	if (rdev->desc->ops->list_voltage)
- 		best_val = rdev->desc->ops->list_voltage(rdev, selector);
- 	else
- 		best_val = -1;
- 
  	/* Call set_voltage_time_sel if successfully obtained old_selector */
- 	if (ret == 0 && old_selector >= 0 &&
  	    rdev->desc->ops->set_voltage_time_sel) {
  
  		delay = rdev->desc->ops->set_voltage_time_sel(rdev,
--- 2098,2142 ----
  	if (rdev->desc->ops->set_voltage) {
  		ret = rdev->desc->ops->set_voltage(rdev, min_uV, max_uV,
  						   &selector);
+ 
+ 		if (ret >= 0) {
+ 			if (rdev->desc->ops->list_voltage)
+ 				best_val = rdev->desc->ops->list_voltage(rdev,
+ 									 selector);
+ 			else
+ 				best_val = _regulator_get_voltage(rdev);
+ 		}
+ 
  	} else if (rdev->desc->ops->set_voltage_sel) {
+ 		if (rdev->desc->ops->map_voltage) {
  			ret = rdev->desc->ops->map_voltage(rdev, min_uV,
  							   max_uV);
+ 		} else {
+ 			if (rdev->desc->ops->list_voltage ==
+ 			    regulator_list_voltage_linear)
+ 				ret = regulator_map_voltage_linear(rdev,
+ 								min_uV, max_uV);
+ 			else
+ 				ret = regulator_map_voltage_iterate(rdev,
+ 								min_uV, max_uV);
+ 		}
  
  		if (ret >= 0) {
+ 			best_val = rdev->desc->ops->list_voltage(rdev, ret);
+ 			if (min_uV <= best_val && max_uV >= best_val) {
+ 				selector = ret;
+ 				ret = rdev->desc->ops->set_voltage_sel(rdev,
+ 								       ret);
+ 			} else {
+ 				ret = -EINVAL;
+ 			}
  		}
  	} else {
  		ret = -EINVAL;
  	}
  
  	/* Call set_voltage_time_sel if successfully obtained old_selector */
+ 	if (ret == 0 && _regulator_is_enabled(rdev) && old_selector >= 0 &&
  	    rdev->desc->ops->set_voltage_time_sel) {
  
  		delay = rdev->desc->ops->set_voltage_time_sel(rdev,
***************
*** 2104,2122 ****
  				  delay);
  			delay = 0;
  		}
- 	}
  
- 	/* Insert any necessary delays */
- 	if (delay >= 1000) {
- 		mdelay(delay / 1000);
- 		udelay(delay % 1000);
- 	} else if (delay) {
- 		udelay(delay);
  	}
  
- 	if (ret == 0)
  		_notifier_call_chain(rdev, REGULATOR_EVENT_VOLTAGE_CHANGE,
- 				     NULL);
  
  	trace_regulator_set_voltage_complete(rdev_get_name(rdev), best_val);
  
--- 2146,2164 ----
  				  delay);
  			delay = 0;
  		}
  
+ 		/* Insert any necessary delays */
+ 		if (delay >= 1000) {
+ 			mdelay(delay / 1000);
+ 			udelay(delay % 1000);
+ 		} else if (delay) {
+ 			udelay(delay);
+ 		}
  	}
  
+ 	if (ret == 0 && best_val >= 0)
  		_notifier_call_chain(rdev, REGULATOR_EVENT_VOLTAGE_CHANGE,
+ 				     (void *)best_val);
  
  	trace_regulator_set_voltage_complete(rdev_get_name(rdev), best_val);
  
***************
*** 2653,2659 ****
  				  unsigned long event, void *data)
  {
  	/* call rdev chain first */
- 	blocking_notifier_call_chain(&rdev->notifier, event, NULL);
  }
  
  /**
--- 2735,2741 ----
  				  unsigned long event, void *data)
  {
  	/* call rdev chain first */
+ 	blocking_notifier_call_chain(&rdev->notifier, event, data);
  }
  
  /**
***************
*** 3130,3136 ****
  	rdev->reg_data = config->driver_data;
  	rdev->owner = regulator_desc->owner;
  	rdev->desc = regulator_desc;
- 	rdev->regmap = config->regmap;
  	INIT_LIST_HEAD(&rdev->consumer_list);
  	INIT_LIST_HEAD(&rdev->list);
  	BLOCKING_INIT_NOTIFIER_HEAD(&rdev->notifier);
--- 3212,3221 ----
  	rdev->reg_data = config->driver_data;
  	rdev->owner = regulator_desc->owner;
  	rdev->desc = regulator_desc;
+ 	if (config->regmap)
+ 		rdev->regmap = config->regmap;
+ 	else
+ 		rdev->regmap = dev_get_regmap(dev, NULL);
  	INIT_LIST_HEAD(&rdev->consumer_list);
  	INIT_LIST_HEAD(&rdev->list);
  	BLOCKING_INIT_NOTIFIER_HEAD(&rdev->notifier);
