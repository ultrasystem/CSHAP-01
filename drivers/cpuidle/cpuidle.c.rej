***************
*** 160,182 ****
  	trace_power_start_rcuidle(POWER_CSTATE, next_state, dev->cpu);
  	trace_cpu_idle_rcuidle(next_state, dev->cpu);
  
- 	entered_state = cpuidle_enter_ops(dev, drv, next_state);
  
  	trace_power_end_rcuidle(dev->cpu);
  	trace_cpu_idle_rcuidle(PWR_EVENT_EXIT, dev->cpu);
  
- 	if (entered_state >= 0) {
- 		/* Update cpuidle counters */
- 		/* This can be moved to within driver enter routine
- 		 * but that results in multiple copies of same code.
- 		 */
- 		dev->states_usage[entered_state].time +=
- 				(unsigned long long)dev->last_residency;
- 		dev->states_usage[entered_state].usage++;
- 	} else {
- 		dev->last_residency = 0;
- 	}
- 
  	/* give the governor an opportunity to reflect on the outcome */
  	if (cpuidle_curr_governor->reflect)
  		cpuidle_curr_governor->reflect(dev, entered_state);
--- 179,193 ----
  	trace_power_start_rcuidle(POWER_CSTATE, next_state, dev->cpu);
  	trace_cpu_idle_rcuidle(next_state, dev->cpu);
  
+ 	if (cpuidle_state_is_coupled(dev, drv, next_state))
+ 		entered_state = cpuidle_enter_state_coupled(dev, drv,
+ 							    next_state);
+ 	else
+ 		entered_state = cpuidle_enter_state(dev, drv, next_state);
  
  	trace_power_end_rcuidle(dev->cpu);
  	trace_cpu_idle_rcuidle(PWR_EVENT_EXIT, dev->cpu);
  
  	/* give the governor an opportunity to reflect on the outcome */
  	if (cpuidle_curr_governor->reflect)
  		cpuidle_curr_governor->reflect(dev, entered_state);
***************
*** 396,408 ****
  
  	per_cpu(cpuidle_devices, dev->cpu) = dev;
  	list_add(&dev->device_list, &cpuidle_detected_devices);
- 	if ((ret = cpuidle_add_sysfs(cpu_dev))) {
- 		module_put(cpuidle_driver->owner);
- 		return ret;
- 	}
  
  	dev->registered = 1;
  	return 0;
  }
  
  /**
--- 424,448 ----
  
  	per_cpu(cpuidle_devices, dev->cpu) = dev;
  	list_add(&dev->device_list, &cpuidle_detected_devices);
+ 	ret = cpuidle_add_sysfs(cpu_dev);
+ 	if (ret)
+ 		goto err_sysfs;
+ 
+ 	ret = cpuidle_coupled_register_device(dev);
+ 	if (ret)
+ 		goto err_coupled;
  
  	dev->registered = 1;
  	return 0;
+ 
+ err_coupled:
+ 	cpuidle_remove_sysfs(cpu_dev);
+ 	wait_for_completion(&dev->kobj_unregister);
+ err_sysfs:
+ 	list_del(&dev->device_list);
+ 	per_cpu(cpuidle_devices, dev->cpu) = NULL;
+ 	module_put(cpuidle_driver->owner);
+ 	return ret;
  }
  
  /**
